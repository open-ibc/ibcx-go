// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/core/vibc/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/cosmos/ibc-go/v7/modules/core/02-client/types"
	types1 "github.com/cosmos/ibc-go/v7/modules/core/04-channel/types"
	_ "github.com/cosmos/ibc-go/v7/modules/core/23-commitment/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgSendPacket defines an sdk.Msg to send a packet.
// It is initiated by the vIBC chain side.
type MsgSendPacket struct {
	SourcePortId    string `protobuf:"bytes,1,opt,name=source_port_id,json=sourcePortId,proto3" json:"source_port_id,omitempty" yaml:"source_port_id"`
	SourceChannelId string `protobuf:"bytes,2,opt,name=source_channel_id,json=sourceChannelId,proto3" json:"source_channel_id,omitempty" yaml:"source_channel_id"`
	Data            []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty" yaml:"data"`
	// Timeout height relative to the current block height.
	// The timeout is disabled when set to 0.
	TimeoutHeight types.Height `protobuf:"bytes,4,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height" yaml:"timeout_height"`
	// Timeout timestamp in absolute nanoseconds since unix epoch.
	// The timeout is disabled when set to 0.
	TimeoutTimestamp uint64 `protobuf:"varint,5,opt,name=timeout_timestamp,json=timeoutTimestamp,proto3" json:"timeout_timestamp,omitempty" yaml:"timeout_timestamp"`
}

func (m *MsgSendPacket) Reset()         { *m = MsgSendPacket{} }
func (m *MsgSendPacket) String() string { return proto.CompactTextString(m) }
func (*MsgSendPacket) ProtoMessage()    {}
func (*MsgSendPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{0}
}
func (m *MsgSendPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendPacket.Merge(m, src)
}
func (m *MsgSendPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendPacket proto.InternalMessageInfo

// MsgSendPacketResponse defines an sdk.Msg for a send packet response.
// It is returned by the vIBC sidecar side.
type MsgSendPacketResponse struct {
	Sequence uint64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty" yaml:"sequence"`
}

func (m *MsgSendPacketResponse) Reset()         { *m = MsgSendPacketResponse{} }
func (m *MsgSendPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendPacketResponse) ProtoMessage()    {}
func (*MsgSendPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{1}
}
func (m *MsgSendPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendPacketResponse.Merge(m, src)
}
func (m *MsgSendPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendPacketResponse proto.InternalMessageInfo

func (m *MsgSendPacketResponse) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

// MsgOnChanOpenInit defines an sdk.Msg to for a channel init callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenInit struct {
	PortId    string          `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string          `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Channel   *types1.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
}

func (m *MsgOnChanOpenInit) Reset()         { *m = MsgOnChanOpenInit{} }
func (m *MsgOnChanOpenInit) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenInit) ProtoMessage()    {}
func (*MsgOnChanOpenInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{2}
}
func (m *MsgOnChanOpenInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenInit.Merge(m, src)
}
func (m *MsgOnChanOpenInit) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenInit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenInit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenInit proto.InternalMessageInfo

// MsgOnChanOpenInitResponse defines the Msg/OnChanOpenInit response type.
type MsgOnChanOpenInitResponse struct {
}

func (m *MsgOnChanOpenInitResponse) Reset()         { *m = MsgOnChanOpenInitResponse{} }
func (m *MsgOnChanOpenInitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenInitResponse) ProtoMessage()    {}
func (*MsgOnChanOpenInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{3}
}
func (m *MsgOnChanOpenInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenInitResponse.Merge(m, src)
}
func (m *MsgOnChanOpenInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenInitResponse proto.InternalMessageInfo

// MsgOnChanOpenTry defines an sdk.Msg to for a channel open try callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenTry struct {
	PortId              string          `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId           string          `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Channel             *types1.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
	CounterpartyVersion string          `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgOnChanOpenTry) Reset()         { *m = MsgOnChanOpenTry{} }
func (m *MsgOnChanOpenTry) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenTry) ProtoMessage()    {}
func (*MsgOnChanOpenTry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{4}
}
func (m *MsgOnChanOpenTry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenTry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenTry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenTry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenTry.Merge(m, src)
}
func (m *MsgOnChanOpenTry) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenTry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenTry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenTry proto.InternalMessageInfo

// MsgOnChanOpenTryResponse defines the Msg/OnChanOpenTry response type.
type MsgOnChanOpenTryResponse struct {
}

func (m *MsgOnChanOpenTryResponse) Reset()         { *m = MsgOnChanOpenTryResponse{} }
func (m *MsgOnChanOpenTryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenTryResponse) ProtoMessage()    {}
func (*MsgOnChanOpenTryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{5}
}
func (m *MsgOnChanOpenTryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenTryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenTryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenTryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenTryResponse.Merge(m, src)
}
func (m *MsgOnChanOpenTryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenTryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenTryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenTryResponse proto.InternalMessageInfo

// MsgOnChanOpenAck defines an sdk.Msg to for a channel open ack callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenAck struct {
	PortId                string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId             string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	CounterpartyChannelId string `protobuf:"bytes,3,opt,name=counterparty_channel_id,json=counterpartyChannelId,proto3" json:"counterparty_channel_id,omitempty" yaml:"counterparty_channel_id"`
	CounterpartyVersion   string `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgOnChanOpenAck) Reset()         { *m = MsgOnChanOpenAck{} }
func (m *MsgOnChanOpenAck) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenAck) ProtoMessage()    {}
func (*MsgOnChanOpenAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{6}
}
func (m *MsgOnChanOpenAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenAck.Merge(m, src)
}
func (m *MsgOnChanOpenAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenAck proto.InternalMessageInfo

// MsgOnChanOpenAckResponse defines the Msg/OnChanOpenAck response type.
type MsgOnChanOpenAckResponse struct {
}

func (m *MsgOnChanOpenAckResponse) Reset()         { *m = MsgOnChanOpenAckResponse{} }
func (m *MsgOnChanOpenAckResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenAckResponse) ProtoMessage()    {}
func (*MsgOnChanOpenAckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{7}
}
func (m *MsgOnChanOpenAckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenAckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenAckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenAckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenAckResponse.Merge(m, src)
}
func (m *MsgOnChanOpenAckResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenAckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenAckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenAckResponse proto.InternalMessageInfo

// MsgOnChanOpenConfirm defines an sdk.Msg to for a channel open Confirm callbConfirm.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenConfirm struct {
	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
}

func (m *MsgOnChanOpenConfirm) Reset()         { *m = MsgOnChanOpenConfirm{} }
func (m *MsgOnChanOpenConfirm) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenConfirm) ProtoMessage()    {}
func (*MsgOnChanOpenConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{8}
}
func (m *MsgOnChanOpenConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenConfirm.Merge(m, src)
}
func (m *MsgOnChanOpenConfirm) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenConfirm proto.InternalMessageInfo

// MsgOnChanOpenConfirmResponse defines the Msg/OnChanOpenConfirm response type.
type MsgOnChanOpenConfirmResponse struct {
}

func (m *MsgOnChanOpenConfirmResponse) Reset()         { *m = MsgOnChanOpenConfirmResponse{} }
func (m *MsgOnChanOpenConfirmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenConfirmResponse) ProtoMessage()    {}
func (*MsgOnChanOpenConfirmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{9}
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenConfirmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenConfirmResponse.Merge(m, src)
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenConfirmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenConfirmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenConfirmResponse proto.InternalMessageInfo

// MsgPostChannelOpenInitOrTry defines an sdk.Msg for the completion of INIT/TRY channel.
// It originates from the vIBC chain side.
type MsgPostChannelOpenInitOrTry struct {
	PortId    string          `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string          `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Channel   *types1.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
}

func (m *MsgPostChannelOpenInitOrTry) Reset()         { *m = MsgPostChannelOpenInitOrTry{} }
func (m *MsgPostChannelOpenInitOrTry) String() string { return proto.CompactTextString(m) }
func (*MsgPostChannelOpenInitOrTry) ProtoMessage()    {}
func (*MsgPostChannelOpenInitOrTry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{10}
}
func (m *MsgPostChannelOpenInitOrTry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostChannelOpenInitOrTry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostChannelOpenInitOrTry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostChannelOpenInitOrTry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostChannelOpenInitOrTry.Merge(m, src)
}
func (m *MsgPostChannelOpenInitOrTry) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostChannelOpenInitOrTry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostChannelOpenInitOrTry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostChannelOpenInitOrTry proto.InternalMessageInfo

// MsgPostChannelOpenInitOrTryResponse defines the Msg/PostChannelOpenInitOrTry response type.
type MsgPostChannelOpenInitOrTryResponse struct {
}

func (m *MsgPostChannelOpenInitOrTryResponse) Reset()         { *m = MsgPostChannelOpenInitOrTryResponse{} }
func (m *MsgPostChannelOpenInitOrTryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPostChannelOpenInitOrTryResponse) ProtoMessage()    {}
func (*MsgPostChannelOpenInitOrTryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{11}
}
func (m *MsgPostChannelOpenInitOrTryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostChannelOpenInitOrTryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostChannelOpenInitOrTryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostChannelOpenInitOrTryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostChannelOpenInitOrTryResponse.Merge(m, src)
}
func (m *MsgPostChannelOpenInitOrTryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostChannelOpenInitOrTryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostChannelOpenInitOrTryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostChannelOpenInitOrTryResponse proto.InternalMessageInfo

// MsgPostChannelOpenAck defines an sdk.Msg for the completion of ACK channel.
// It originates from the vIBC chain side.
type MsgPostChannelOpenAck struct {
	PortId                string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId             string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	CounterpartyChannelId string `protobuf:"bytes,3,opt,name=counterparty_channel_id,json=counterpartyChannelId,proto3" json:"counterparty_channel_id,omitempty" yaml:"counterparty_channel_id"`
	CounterpartyVersion   string `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgPostChannelOpenAck) Reset()         { *m = MsgPostChannelOpenAck{} }
func (m *MsgPostChannelOpenAck) String() string { return proto.CompactTextString(m) }
func (*MsgPostChannelOpenAck) ProtoMessage()    {}
func (*MsgPostChannelOpenAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{12}
}
func (m *MsgPostChannelOpenAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostChannelOpenAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostChannelOpenAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostChannelOpenAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostChannelOpenAck.Merge(m, src)
}
func (m *MsgPostChannelOpenAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostChannelOpenAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostChannelOpenAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostChannelOpenAck proto.InternalMessageInfo

// MsgPostChannelOpenAckResponse defines the Msg/PostChannelOpenAck response type.
type MsgPostChannelOpenAckResponse struct {
}

func (m *MsgPostChannelOpenAckResponse) Reset()         { *m = MsgPostChannelOpenAckResponse{} }
func (m *MsgPostChannelOpenAckResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPostChannelOpenAckResponse) ProtoMessage()    {}
func (*MsgPostChannelOpenAckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{13}
}
func (m *MsgPostChannelOpenAckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostChannelOpenAckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostChannelOpenAckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostChannelOpenAckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostChannelOpenAckResponse.Merge(m, src)
}
func (m *MsgPostChannelOpenAckResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostChannelOpenAckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostChannelOpenAckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostChannelOpenAckResponse proto.InternalMessageInfo

// MsgPostChannelOpenConfirm defines an sdk.Msg for the completion of CONFIRM channel.
// It originates from the vIBC chain side.
type MsgPostChannelOpenConfirm struct {
	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
}

func (m *MsgPostChannelOpenConfirm) Reset()         { *m = MsgPostChannelOpenConfirm{} }
func (m *MsgPostChannelOpenConfirm) String() string { return proto.CompactTextString(m) }
func (*MsgPostChannelOpenConfirm) ProtoMessage()    {}
func (*MsgPostChannelOpenConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{14}
}
func (m *MsgPostChannelOpenConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostChannelOpenConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostChannelOpenConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostChannelOpenConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostChannelOpenConfirm.Merge(m, src)
}
func (m *MsgPostChannelOpenConfirm) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostChannelOpenConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostChannelOpenConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostChannelOpenConfirm proto.InternalMessageInfo

// MsgPostChannelOpenConfirmResponse defines the Msg/PostChannelOpenConfirm response type.
type MsgPostChannelOpenConfirmResponse struct {
}

func (m *MsgPostChannelOpenConfirmResponse) Reset()         { *m = MsgPostChannelOpenConfirmResponse{} }
func (m *MsgPostChannelOpenConfirmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPostChannelOpenConfirmResponse) ProtoMessage()    {}
func (*MsgPostChannelOpenConfirmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{15}
}
func (m *MsgPostChannelOpenConfirmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostChannelOpenConfirmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostChannelOpenConfirmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostChannelOpenConfirmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostChannelOpenConfirmResponse.Merge(m, src)
}
func (m *MsgPostChannelOpenConfirmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostChannelOpenConfirmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostChannelOpenConfirmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostChannelOpenConfirmResponse proto.InternalMessageInfo

// MsgOnRecvPacket defines an sdk.Msg to for a packet receipt.
// It originates from the vIBC sidecar side.
type MsgOnRecvPacket struct {
	Packet  types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Relayer string        `protobuf:"bytes,2,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnRecvPacket) Reset()         { *m = MsgOnRecvPacket{} }
func (m *MsgOnRecvPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnRecvPacket) ProtoMessage()    {}
func (*MsgOnRecvPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{16}
}
func (m *MsgOnRecvPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnRecvPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnRecvPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnRecvPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnRecvPacket.Merge(m, src)
}
func (m *MsgOnRecvPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnRecvPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnRecvPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnRecvPacket proto.InternalMessageInfo

// MsgOnRecvPacketResponse defines the Msg/OnRecvPacket response type.
type MsgOnRecvPacketResponse struct {
}

func (m *MsgOnRecvPacketResponse) Reset()         { *m = MsgOnRecvPacketResponse{} }
func (m *MsgOnRecvPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnRecvPacketResponse) ProtoMessage()    {}
func (*MsgOnRecvPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{17}
}
func (m *MsgOnRecvPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnRecvPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnRecvPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnRecvPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnRecvPacketResponse.Merge(m, src)
}
func (m *MsgOnRecvPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnRecvPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnRecvPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnRecvPacketResponse proto.InternalMessageInfo

// MsgOnTimeoutPacket defines an sdk.Msg to for a packet receipt.
// It originates from the vIBC sidecar side.
type MsgOnTimeoutPacket struct {
	Packet  types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Relayer string        `protobuf:"bytes,2,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnTimeoutPacket) Reset()         { *m = MsgOnTimeoutPacket{} }
func (m *MsgOnTimeoutPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnTimeoutPacket) ProtoMessage()    {}
func (*MsgOnTimeoutPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{18}
}
func (m *MsgOnTimeoutPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnTimeoutPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnTimeoutPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnTimeoutPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnTimeoutPacket.Merge(m, src)
}
func (m *MsgOnTimeoutPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnTimeoutPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnTimeoutPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnTimeoutPacket proto.InternalMessageInfo

// MsgOnTimeoutPacketResponse defines the Msg/OnTimeoutPacket response type.
type MsgOnTimeoutPacketResponse struct {
}

func (m *MsgOnTimeoutPacketResponse) Reset()         { *m = MsgOnTimeoutPacketResponse{} }
func (m *MsgOnTimeoutPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnTimeoutPacketResponse) ProtoMessage()    {}
func (*MsgOnTimeoutPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{19}
}
func (m *MsgOnTimeoutPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnTimeoutPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnTimeoutPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnTimeoutPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnTimeoutPacketResponse.Merge(m, src)
}
func (m *MsgOnTimeoutPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnTimeoutPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnTimeoutPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnTimeoutPacketResponse proto.InternalMessageInfo

// MsgOnAcknowledgementPacket defines an sdk.Msg to for a packet acknowledgement.
// It originates from the vIBC sidecar side.
type MsgOnAcknowledgementPacket struct {
	Packet          types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Acknowledgement []byte        `protobuf:"bytes,2,opt,name=acknowledgement,proto3" json:"acknowledgement,omitempty"`
	Relayer         string        `protobuf:"bytes,3,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnAcknowledgementPacket) Reset()         { *m = MsgOnAcknowledgementPacket{} }
func (m *MsgOnAcknowledgementPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnAcknowledgementPacket) ProtoMessage()    {}
func (*MsgOnAcknowledgementPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{20}
}
func (m *MsgOnAcknowledgementPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnAcknowledgementPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnAcknowledgementPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnAcknowledgementPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnAcknowledgementPacket.Merge(m, src)
}
func (m *MsgOnAcknowledgementPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnAcknowledgementPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnAcknowledgementPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnAcknowledgementPacket proto.InternalMessageInfo

// MsgOnAcknowledgementPacketResponse defines the Msg/OnAcknowledgementPacket response type.
type MsgOnAcknowledgementPacketResponse struct {
}

func (m *MsgOnAcknowledgementPacketResponse) Reset()         { *m = MsgOnAcknowledgementPacketResponse{} }
func (m *MsgOnAcknowledgementPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnAcknowledgementPacketResponse) ProtoMessage()    {}
func (*MsgOnAcknowledgementPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{21}
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnAcknowledgementPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnAcknowledgementPacketResponse.Merge(m, src)
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnAcknowledgementPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnAcknowledgementPacketResponse proto.InternalMessageInfo

// MsgPostRecvPacket defines an sdk.Msg to for completing the recv packet flow.
// It originates from the vIBC chain side.
type MsgPostRecvPacket struct {
	Packet          types1.Packet           `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Acknowledgement *types1.Acknowledgement `protobuf:"bytes,2,opt,name=acknowledgement,proto3" json:"acknowledgement,omitempty"`
}

func (m *MsgPostRecvPacket) Reset()         { *m = MsgPostRecvPacket{} }
func (m *MsgPostRecvPacket) String() string { return proto.CompactTextString(m) }
func (*MsgPostRecvPacket) ProtoMessage()    {}
func (*MsgPostRecvPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{22}
}
func (m *MsgPostRecvPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostRecvPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostRecvPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostRecvPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostRecvPacket.Merge(m, src)
}
func (m *MsgPostRecvPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostRecvPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostRecvPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostRecvPacket proto.InternalMessageInfo

type MsgPostRecvPacketResponse struct {
}

func (m *MsgPostRecvPacketResponse) Reset()         { *m = MsgPostRecvPacketResponse{} }
func (m *MsgPostRecvPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPostRecvPacketResponse) ProtoMessage()    {}
func (*MsgPostRecvPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{23}
}
func (m *MsgPostRecvPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostRecvPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostRecvPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostRecvPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostRecvPacketResponse.Merge(m, src)
}
func (m *MsgPostRecvPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostRecvPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostRecvPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostRecvPacketResponse proto.InternalMessageInfo

// MsgPostAcknowledgementPacket defines an sdk.Msg for completing the acknowledgement flow.
// It originates from the vIBC chain side.
type MsgPostAcknowledgementPacket struct {
	Packet types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
}

func (m *MsgPostAcknowledgementPacket) Reset()         { *m = MsgPostAcknowledgementPacket{} }
func (m *MsgPostAcknowledgementPacket) String() string { return proto.CompactTextString(m) }
func (*MsgPostAcknowledgementPacket) ProtoMessage()    {}
func (*MsgPostAcknowledgementPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{24}
}
func (m *MsgPostAcknowledgementPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostAcknowledgementPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostAcknowledgementPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostAcknowledgementPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostAcknowledgementPacket.Merge(m, src)
}
func (m *MsgPostAcknowledgementPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostAcknowledgementPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostAcknowledgementPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostAcknowledgementPacket proto.InternalMessageInfo

type MsgPostAcknowledgementPacketResponse struct {
}

func (m *MsgPostAcknowledgementPacketResponse) Reset()         { *m = MsgPostAcknowledgementPacketResponse{} }
func (m *MsgPostAcknowledgementPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPostAcknowledgementPacketResponse) ProtoMessage()    {}
func (*MsgPostAcknowledgementPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{25}
}
func (m *MsgPostAcknowledgementPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostAcknowledgementPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostAcknowledgementPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostAcknowledgementPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostAcknowledgementPacketResponse.Merge(m, src)
}
func (m *MsgPostAcknowledgementPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostAcknowledgementPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostAcknowledgementPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostAcknowledgementPacketResponse proto.InternalMessageInfo

// MsgPostTimeoutPacket defines an sdk.Msg for completing the timeout flow.
// It originates from the vIBC chain side.
type MsgPostTimeoutPacket struct {
	Packet types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
}

func (m *MsgPostTimeoutPacket) Reset()         { *m = MsgPostTimeoutPacket{} }
func (m *MsgPostTimeoutPacket) String() string { return proto.CompactTextString(m) }
func (*MsgPostTimeoutPacket) ProtoMessage()    {}
func (*MsgPostTimeoutPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{26}
}
func (m *MsgPostTimeoutPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostTimeoutPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostTimeoutPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostTimeoutPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostTimeoutPacket.Merge(m, src)
}
func (m *MsgPostTimeoutPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostTimeoutPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostTimeoutPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostTimeoutPacket proto.InternalMessageInfo

type MsgPostTimeoutPacketResponse struct {
}

func (m *MsgPostTimeoutPacketResponse) Reset()         { *m = MsgPostTimeoutPacketResponse{} }
func (m *MsgPostTimeoutPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgPostTimeoutPacketResponse) ProtoMessage()    {}
func (*MsgPostTimeoutPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{27}
}
func (m *MsgPostTimeoutPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPostTimeoutPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPostTimeoutPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPostTimeoutPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPostTimeoutPacketResponse.Merge(m, src)
}
func (m *MsgPostTimeoutPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgPostTimeoutPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPostTimeoutPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPostTimeoutPacketResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgSendPacket)(nil), "ibc.core.vibc.v1.MsgSendPacket")
	proto.RegisterType((*MsgSendPacketResponse)(nil), "ibc.core.vibc.v1.MsgSendPacketResponse")
	proto.RegisterType((*MsgOnChanOpenInit)(nil), "ibc.core.vibc.v1.MsgOnChanOpenInit")
	proto.RegisterType((*MsgOnChanOpenInitResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenInitResponse")
	proto.RegisterType((*MsgOnChanOpenTry)(nil), "ibc.core.vibc.v1.MsgOnChanOpenTry")
	proto.RegisterType((*MsgOnChanOpenTryResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenTryResponse")
	proto.RegisterType((*MsgOnChanOpenAck)(nil), "ibc.core.vibc.v1.MsgOnChanOpenAck")
	proto.RegisterType((*MsgOnChanOpenAckResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenAckResponse")
	proto.RegisterType((*MsgOnChanOpenConfirm)(nil), "ibc.core.vibc.v1.MsgOnChanOpenConfirm")
	proto.RegisterType((*MsgOnChanOpenConfirmResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenConfirmResponse")
	proto.RegisterType((*MsgPostChannelOpenInitOrTry)(nil), "ibc.core.vibc.v1.MsgPostChannelOpenInitOrTry")
	proto.RegisterType((*MsgPostChannelOpenInitOrTryResponse)(nil), "ibc.core.vibc.v1.MsgPostChannelOpenInitOrTryResponse")
	proto.RegisterType((*MsgPostChannelOpenAck)(nil), "ibc.core.vibc.v1.MsgPostChannelOpenAck")
	proto.RegisterType((*MsgPostChannelOpenAckResponse)(nil), "ibc.core.vibc.v1.MsgPostChannelOpenAckResponse")
	proto.RegisterType((*MsgPostChannelOpenConfirm)(nil), "ibc.core.vibc.v1.MsgPostChannelOpenConfirm")
	proto.RegisterType((*MsgPostChannelOpenConfirmResponse)(nil), "ibc.core.vibc.v1.MsgPostChannelOpenConfirmResponse")
	proto.RegisterType((*MsgOnRecvPacket)(nil), "ibc.core.vibc.v1.MsgOnRecvPacket")
	proto.RegisterType((*MsgOnRecvPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnRecvPacketResponse")
	proto.RegisterType((*MsgOnTimeoutPacket)(nil), "ibc.core.vibc.v1.MsgOnTimeoutPacket")
	proto.RegisterType((*MsgOnTimeoutPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnTimeoutPacketResponse")
	proto.RegisterType((*MsgOnAcknowledgementPacket)(nil), "ibc.core.vibc.v1.MsgOnAcknowledgementPacket")
	proto.RegisterType((*MsgOnAcknowledgementPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnAcknowledgementPacketResponse")
	proto.RegisterType((*MsgPostRecvPacket)(nil), "ibc.core.vibc.v1.MsgPostRecvPacket")
	proto.RegisterType((*MsgPostRecvPacketResponse)(nil), "ibc.core.vibc.v1.MsgPostRecvPacketResponse")
	proto.RegisterType((*MsgPostAcknowledgementPacket)(nil), "ibc.core.vibc.v1.MsgPostAcknowledgementPacket")
	proto.RegisterType((*MsgPostAcknowledgementPacketResponse)(nil), "ibc.core.vibc.v1.MsgPostAcknowledgementPacketResponse")
	proto.RegisterType((*MsgPostTimeoutPacket)(nil), "ibc.core.vibc.v1.MsgPostTimeoutPacket")
	proto.RegisterType((*MsgPostTimeoutPacketResponse)(nil), "ibc.core.vibc.v1.MsgPostTimeoutPacketResponse")
}

func init() { proto.RegisterFile("ibc/core/vibc/v1/tx.proto", fileDescriptor_9d1a3d740386b8a9) }

var fileDescriptor_9d1a3d740386b8a9 = []byte{
	// 1172 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xbd, 0x4f, 0xe3, 0x66,
	0x18, 0x8f, 0x81, 0x83, 0xe3, 0xe1, 0x23, 0xe0, 0x83, 0x12, 0x0c, 0x17, 0x83, 0xa1, 0x90, 0x96,
	0x3b, 0x5b, 0x84, 0xeb, 0x55, 0xbd, 0xa5, 0x22, 0x2c, 0x64, 0xa0, 0x20, 0x17, 0x31, 0x5c, 0x2b,
	0xa5, 0x8e, 0xf3, 0x36, 0xb1, 0x12, 0xfb, 0x75, 0x6d, 0x27, 0x6d, 0x2a, 0x55, 0xaa, 0x74, 0xcb,
	0x49, 0x5d, 0xfa, 0x27, 0xdc, 0x52, 0xa9, 0xea, 0xd2, 0xa5, 0x43, 0xe7, 0x4e, 0x37, 0xde, 0xd8,
	0x29, 0xaa, 0x60, 0xb9, 0x39, 0x43, 0xe7, 0xca, 0x5f, 0x6f, 0xfc, 0x79, 0x09, 0x2a, 0xa2, 0x37,
	0x74, 0xc2, 0x79, 0x9f, 0x9f, 0x7f, 0xcf, 0xef, 0xf9, 0x78, 0xdf, 0xf7, 0xc1, 0xb0, 0xaa, 0x54,
	0x65, 0x41, 0xc6, 0x06, 0x12, 0x3a, 0xf6, 0x53, 0x67, 0x5f, 0xb0, 0xbe, 0xe1, 0x75, 0x03, 0x5b,
	0x98, 0x5e, 0x50, 0xaa, 0x32, 0x6f, 0x9b, 0x78, 0xdb, 0xc4, 0x77, 0xf6, 0x99, 0xa5, 0x3a, 0xae,
	0x63, 0xc7, 0x28, 0xd8, 0x4f, 0x2e, 0x8e, 0x61, 0x09, 0x85, 0xdc, 0x52, 0x90, 0x66, 0xd9, 0x24,
	0xee, 0x93, 0x07, 0xd8, 0x1c, 0x00, 0x1a, 0x92, 0xa6, 0xa1, 0x96, 0x83, 0x70, 0x1f, 0x3d, 0xc8,
	0xee, 0x00, 0x82, 0x55, 0x55, 0xb1, 0x54, 0x9f, 0x87, 0xfc, 0x72, 0x81, 0xdc, 0xdf, 0x63, 0x30,
	0x77, 0x62, 0xd6, 0x3f, 0x45, 0x5a, 0xed, 0x4c, 0x92, 0x9b, 0xc8, 0xa2, 0x3f, 0x86, 0x79, 0x13,
	0xb7, 0x0d, 0x19, 0x55, 0x74, 0x6c, 0x58, 0x15, 0xa5, 0x96, 0xa3, 0x36, 0xa8, 0xc2, 0x74, 0x69,
	0xb5, 0xdf, 0x63, 0x97, 0xbb, 0x92, 0xda, 0x7a, 0xc2, 0x85, 0xed, 0x9c, 0x38, 0xeb, 0x2e, 0x9c,
	0x61, 0xc3, 0x2a, 0xd7, 0xe8, 0x63, 0x58, 0xf4, 0x00, 0x9e, 0x26, 0x9b, 0x63, 0xcc, 0xe1, 0x58,
	0xef, 0xf7, 0xd8, 0x5c, 0x88, 0x63, 0x00, 0xe1, 0xc4, 0xac, 0xbb, 0x76, 0xe4, 0x2e, 0x95, 0x6b,
	0xf4, 0x16, 0x4c, 0xd4, 0x24, 0x4b, 0xca, 0x8d, 0x6f, 0x50, 0x85, 0xd9, 0x52, 0xb6, 0xdf, 0x63,
	0x67, 0xdc, 0x97, 0xed, 0x55, 0x4e, 0x74, 0x8c, 0xf4, 0x17, 0x30, 0x6f, 0x29, 0x2a, 0xc2, 0x6d,
	0xab, 0xd2, 0x40, 0x4a, 0xbd, 0x61, 0xe5, 0x26, 0x36, 0xa8, 0xc2, 0x4c, 0x91, 0xe1, 0x49, 0xbe,
	0xbd, 0xec, 0x75, 0xf6, 0xf9, 0x63, 0x07, 0x51, 0xba, 0xff, 0xb2, 0xc7, 0x66, 0x06, 0xf1, 0x84,
	0xdf, 0xe7, 0xc4, 0x39, 0x6f, 0xc1, 0x45, 0xd3, 0x65, 0x58, 0xf4, 0x11, 0xf6, 0x5f, 0xd3, 0x92,
	0x54, 0x3d, 0x77, 0x67, 0x83, 0x2a, 0x4c, 0x04, 0x03, 0x8a, 0x41, 0x38, 0x71, 0xc1, 0x5b, 0x3b,
	0xf7, 0x97, 0x9e, 0xdc, 0x7d, 0xfe, 0x82, 0xcd, 0xbc, 0x7e, 0xc1, 0x66, 0xb8, 0x63, 0x58, 0x0e,
	0xe5, 0x5d, 0x44, 0xa6, 0x8e, 0x35, 0x13, 0xd1, 0x02, 0xdc, 0x35, 0xd1, 0x57, 0x6d, 0xa4, 0xc9,
	0xc8, 0xc9, 0xfc, 0x44, 0xe9, 0x5e, 0xbf, 0xc7, 0x66, 0xbd, 0xac, 0x79, 0x16, 0x4e, 0x24, 0x20,
	0xee, 0x77, 0x0a, 0x16, 0x4f, 0xcc, 0xfa, 0xa9, 0x66, 0x27, 0xee, 0x54, 0x47, 0x5a, 0x59, 0x53,
	0x2c, 0x7a, 0x0f, 0xa6, 0xc2, 0xf5, 0xa3, 0xfb, 0x3d, 0x76, 0xde, 0x65, 0x21, 0x85, 0x9b, 0xd4,
	0xdd, 0x92, 0x3d, 0x02, 0x88, 0xd5, 0x6a, 0xb9, 0xdf, 0x63, 0x17, 0x5d, 0x7c, 0xb0, 0x48, 0xd3,
	0x32, 0x29, 0xcf, 0x63, 0x98, 0xf2, 0x7e, 0x38, 0x15, 0x9a, 0x29, 0xae, 0x07, 0x52, 0xee, 0xb5,
	0x63, 0x67, 0x9f, 0xf7, 0xea, 0x29, 0xfa, 0xe0, 0x40, 0x12, 0xd6, 0x60, 0x35, 0xa6, 0xdc, 0x4f,
	0x04, 0xf7, 0xc3, 0x18, 0x2c, 0x84, 0xac, 0xe7, 0x46, 0xf7, 0x2d, 0x0e, 0x8b, 0x16, 0x61, 0x49,
	0xc6, 0x6d, 0xcd, 0x42, 0x86, 0x2e, 0x19, 0x56, 0xb7, 0xd2, 0x41, 0x86, 0xa9, 0x60, 0xcd, 0x69,
	0xc7, 0xe9, 0x12, 0xdb, 0xef, 0xb1, 0x6b, 0x9e, 0xdf, 0x04, 0x14, 0x27, 0xde, 0x0b, 0x2e, 0x5f,
	0xb8, 0xab, 0x81, 0x54, 0x31, 0x90, 0x8b, 0x26, 0x83, 0x64, 0xea, 0xd7, 0x68, 0xa6, 0x0e, 0xe5,
	0xe6, 0x6d, 0x64, 0xea, 0x29, 0xac, 0x84, 0x62, 0x09, 0x50, 0x8c, 0x3b, 0x14, 0x5c, 0xbf, 0xc7,
	0xe6, 0x13, 0x82, 0x0e, 0xf2, 0x2d, 0x07, 0x2d, 0x83, 0xbd, 0x7f, 0xbb, 0xd9, 0x3c, 0x94, 0x9b,
	0x24, 0x9b, 0xcf, 0x28, 0x58, 0x0a, 0x19, 0x8f, 0xb0, 0xf6, 0xa5, 0x62, 0xa8, 0xb7, 0x90, 0xd1,
	0x80, 0xc2, 0x3c, 0xac, 0x27, 0x89, 0x20, 0x2a, 0xff, 0xa0, 0x60, 0xed, 0xc4, 0xac, 0x9f, 0x61,
	0xd3, 0xf2, 0x92, 0xe6, 0x6f, 0xa0, 0x53, 0xe3, 0xed, 0xde, 0x28, 0x81, 0x20, 0xdf, 0x85, 0xad,
	0x37, 0xc4, 0x40, 0x62, 0xfd, 0x6d, 0xcc, 0x39, 0x2c, 0x23, 0xb8, 0xff, 0x9b, 0x7c, 0x48, 0x93,
	0xb3, 0x70, 0x3f, 0x31, 0x6b, 0x24, 0xaf, 0xcf, 0x29, 0xe7, 0xfc, 0x8d, 0x20, 0xfe, 0x93, 0x76,
	0xdf, 0x82, 0xcd, 0x54, 0x25, 0x44, 0xaf, 0x0e, 0x59, 0x67, 0x4f, 0x88, 0x48, 0xee, 0x78, 0xd3,
	0xca, 0x47, 0x30, 0xa9, 0x3b, 0x4f, 0x8e, 0xc6, 0x99, 0xe2, 0x5a, 0x62, 0x0b, 0xba, 0xe0, 0xd2,
	0x84, 0x7d, 0xed, 0x8b, 0xde, 0x0b, 0x74, 0x0e, 0xa6, 0x0c, 0xd4, 0x92, 0xba, 0xc8, 0x70, 0xf5,
	0x8a, 0xfe, 0xcf, 0x80, 0xac, 0x55, 0x58, 0x89, 0x78, 0x24, 0x62, 0x4c, 0xa0, 0x1d, 0xd3, 0xb9,
	0x7b, 0xc7, 0xdf, 0x8e, 0x9e, 0x75, 0x60, 0xe2, 0x4e, 0x89, 0xa4, 0x9f, 0x28, 0xcf, 0x7c, 0x28,
	0x37, 0x35, 0xfc, 0x75, 0x0b, 0xd5, 0xea, 0xc8, 0x9e, 0xf5, 0xfe, 0xbd, 0xb6, 0x02, 0x64, 0xa5,
	0x30, 0xa7, 0xa3, 0x71, 0x56, 0x8c, 0x2e, 0x07, 0xa3, 0x18, 0x4f, 0x8b, 0x62, 0x1b, 0xb8, 0x74,
	0x99, 0x24, 0x9a, 0x9f, 0xdd, 0xb9, 0xc6, 0xee, 0x89, 0x9b, 0x29, 0xf8, 0x27, 0xc9, 0x41, 0xcc,
	0x14, 0xb7, 0x13, 0x39, 0x22, 0xea, 0x62, 0xa1, 0xc6, 0xe6, 0x98, 0xb0, 0x52, 0x12, 0x87, 0xec,
	0x9c, 0xe4, 0xb6, 0xf1, 0xa6, 0xcb, 0x12, 0x50, 0xb0, 0x03, 0xdb, 0x6f, 0x72, 0x42, 0xc4, 0x7c,
	0xe6, 0xdc, 0x6d, 0x36, 0xee, 0xa6, 0xfa, 0x36, 0x76, 0x67, 0xc5, 0xc8, 0x7d, 0xe7, 0xc5, 0xd7,
	0x77, 0x20, 0x7b, 0xa1, 0x18, 0x56, 0x5b, 0x6a, 0x95, 0x4b, 0x47, 0x47, 0x0d, 0x49, 0xd1, 0xe8,
	0x2a, 0xcc, 0x47, 0x26, 0xd7, 0x2d, 0x3e, 0xfa, 0x8f, 0x12, 0x1f, 0x1b, 0x12, 0x99, 0xbd, 0x11,
	0x40, 0x64, 0xa4, 0xae, 0xc0, 0x5c, 0x78, 0x8a, 0xe4, 0x86, 0xbc, 0x7d, 0x6e, 0x74, 0x99, 0xf7,
	0x87, 0x63, 0x92, 0x1d, 0xd8, 0xf7, 0xd2, 0x30, 0x07, 0x87, 0x72, 0x73, 0xa8, 0x83, 0xc0, 0x49,
	0x4d, 0x37, 0x61, 0x31, 0x3e, 0x8f, 0xec, 0x0c, 0x21, 0xf0, 0x70, 0x0c, 0x3f, 0x1a, 0x8e, 0x38,
	0xfb, 0x1c, 0x66, 0x43, 0x67, 0xec, 0x66, 0xca, 0xfb, 0x03, 0x08, 0xf3, 0xde, 0x50, 0x08, 0x61,
	0xff, 0x0e, 0x56, 0xd2, 0x0e, 0xa8, 0x07, 0x29, 0x2c, 0x89, 0x68, 0xe6, 0xd1, 0x75, 0xd0, 0xc4,
	0x3d, 0x82, 0x6c, 0xf4, 0xcc, 0xde, 0x4e, 0x21, 0x0a, 0xa1, 0x98, 0x07, 0xa3, 0xa0, 0x48, 0xab,
	0xff, 0x32, 0x09, 0x30, 0x68, 0x75, 0xfa, 0x7b, 0x0a, 0x72, 0xa9, 0xa3, 0xda, 0xc3, 0x44, 0xe6,
	0x34, 0x38, 0xf3, 0xc1, 0xb5, 0xe0, 0x24, 0x70, 0x0d, 0xe8, 0x84, 0x01, 0x6a, 0x77, 0x14, 0x32,
	0xbb, 0x5b, 0x85, 0x11, 0x81, 0xc4, 0xdf, 0xb7, 0xf0, 0x4e, 0xda, 0x60, 0x31, 0x0a, 0x95, 0xdf,
	0xbc, 0x07, 0xd7, 0x00, 0x13, 0xdf, 0x17, 0x00, 0x81, 0x2f, 0x1a, 0x6c, 0x22, 0xc5, 0x00, 0xc0,
	0xec, 0x0e, 0x01, 0x10, 0xde, 0x2a, 0xcc, 0x47, 0xae, 0xa3, 0xad, 0x54, 0x79, 0x81, 0xdd, 0xb1,
	0x37, 0x02, 0x88, 0xf8, 0x78, 0x46, 0xc1, 0x6a, 0xfa, 0x65, 0xc1, 0xa7, 0x52, 0x25, 0x6f, 0x92,
	0xc7, 0xd7, 0xc3, 0x07, 0x0f, 0x9c, 0xf8, 0x25, 0xb1, 0x93, 0x4a, 0x16, 0xde, 0x2a, 0xfc, 0x68,
	0x38, 0xdf, 0x59, 0xe9, 0xe4, 0xe5, 0x65, 0x9e, 0x7a, 0x75, 0x99, 0xa7, 0xfe, 0xba, 0xcc, 0x53,
	0x3f, 0x5e, 0xe5, 0x33, 0xaf, 0xae, 0xf2, 0x99, 0x3f, 0xaf, 0xf2, 0x99, 0xa7, 0x07, 0x75, 0xc5,
	0x6a, 0xb4, 0xab, 0xbc, 0x8c, 0x55, 0x41, 0xc6, 0xa6, 0x8a, 0x4d, 0x41, 0xa9, 0xca, 0x0f, 0xeb,
	0x58, 0xe8, 0x7c, 0x28, 0xa8, 0xb8, 0xd6, 0x6e, 0x21, 0x33, 0xf0, 0xb9, 0xcd, 0xea, 0xea, 0xc8,
	0xac, 0x4e, 0x3a, 0x9f, 0xb6, 0x0e, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x48, 0x40, 0x0b, 0x7f,
	0x8c, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VirtualIBCChainClient is the client API for VirtualIBCChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VirtualIBCChainClient interface {
	// OnChanOpenInit defines a rpc handler method for MsgOnChanOpenInit.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<INIT>
	OnChanOpenInit(ctx context.Context, in *MsgOnChanOpenInit, opts ...grpc.CallOption) (*MsgOnChanOpenInitResponse, error)
	// OnChanOpenTry defines a rpc handler method for MsgOnChanOpenTry.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<TRYOPEN>
	OnChanOpenTry(ctx context.Context, in *MsgOnChanOpenTry, opts ...grpc.CallOption) (*MsgOnChanOpenTryResponse, error)
	// OnChanOpenAck defines a rpc handler method for MsgOnChanOpenAck.
	// Proofs:
	// - exists: channel<INIT>
	// - non-exists: channel<OPEN>
	OnChanOpenAck(ctx context.Context, in *MsgOnChanOpenAck, opts ...grpc.CallOption) (*MsgOnChanOpenAckResponse, error)
	// OnChanOpenConfirm defines a rpc handler method for MsgOnChanOpenConfirm.
	// Proofs:
	// - exists: channel<TRYOPEN>
	// - non-exists: channel<OPEN>
	OnChanOpenConfirm(ctx context.Context, in *MsgOnChanOpenConfirm, opts ...grpc.CallOption) (*MsgOnChanOpenConfirmResponse, error)
	// OnRecvPacket defines a rpc handler method for MsgOnRecvPacket.
	// Proofs:
	// - exists: packet commitment
	// - exists: packet receipt OR packet recv sequence
	OnRecvPacket(ctx context.Context, in *MsgOnRecvPacket, opts ...grpc.CallOption) (*MsgOnRecvPacketResponse, error)
	// OnAcknowledgementPacket defines a rpc handler method for MsgOnAcknowledgementPacket.
	OnAcknowledgementPacket(ctx context.Context, in *MsgOnAcknowledgementPacket, opts ...grpc.CallOption) (*MsgOnAcknowledgementPacketResponse, error)
	// OnTimeoutPacket defines a rpc handler method for MsgOnTimeoutPacket.
	OnTimeoutPacket(ctx context.Context, in *MsgOnTimeoutPacket, opts ...grpc.CallOption) (*MsgOnTimeoutPacketResponse, error)
}

type virtualIBCChainClient struct {
	cc grpc1.ClientConn
}

func NewVirtualIBCChainClient(cc grpc1.ClientConn) VirtualIBCChainClient {
	return &virtualIBCChainClient{cc}
}

func (c *virtualIBCChainClient) OnChanOpenInit(ctx context.Context, in *MsgOnChanOpenInit, opts ...grpc.CallOption) (*MsgOnChanOpenInitResponse, error) {
	out := new(MsgOnChanOpenInitResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenTry(ctx context.Context, in *MsgOnChanOpenTry, opts ...grpc.CallOption) (*MsgOnChanOpenTryResponse, error) {
	out := new(MsgOnChanOpenTryResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenTry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenAck(ctx context.Context, in *MsgOnChanOpenAck, opts ...grpc.CallOption) (*MsgOnChanOpenAckResponse, error) {
	out := new(MsgOnChanOpenAckResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenConfirm(ctx context.Context, in *MsgOnChanOpenConfirm, opts ...grpc.CallOption) (*MsgOnChanOpenConfirmResponse, error) {
	out := new(MsgOnChanOpenConfirmResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenConfirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnRecvPacket(ctx context.Context, in *MsgOnRecvPacket, opts ...grpc.CallOption) (*MsgOnRecvPacketResponse, error) {
	out := new(MsgOnRecvPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnRecvPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnAcknowledgementPacket(ctx context.Context, in *MsgOnAcknowledgementPacket, opts ...grpc.CallOption) (*MsgOnAcknowledgementPacketResponse, error) {
	out := new(MsgOnAcknowledgementPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnAcknowledgementPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnTimeoutPacket(ctx context.Context, in *MsgOnTimeoutPacket, opts ...grpc.CallOption) (*MsgOnTimeoutPacketResponse, error) {
	out := new(MsgOnTimeoutPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnTimeoutPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualIBCChainServer is the server API for VirtualIBCChain service.
type VirtualIBCChainServer interface {
	// OnChanOpenInit defines a rpc handler method for MsgOnChanOpenInit.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<INIT>
	OnChanOpenInit(context.Context, *MsgOnChanOpenInit) (*MsgOnChanOpenInitResponse, error)
	// OnChanOpenTry defines a rpc handler method for MsgOnChanOpenTry.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<TRYOPEN>
	OnChanOpenTry(context.Context, *MsgOnChanOpenTry) (*MsgOnChanOpenTryResponse, error)
	// OnChanOpenAck defines a rpc handler method for MsgOnChanOpenAck.
	// Proofs:
	// - exists: channel<INIT>
	// - non-exists: channel<OPEN>
	OnChanOpenAck(context.Context, *MsgOnChanOpenAck) (*MsgOnChanOpenAckResponse, error)
	// OnChanOpenConfirm defines a rpc handler method for MsgOnChanOpenConfirm.
	// Proofs:
	// - exists: channel<TRYOPEN>
	// - non-exists: channel<OPEN>
	OnChanOpenConfirm(context.Context, *MsgOnChanOpenConfirm) (*MsgOnChanOpenConfirmResponse, error)
	// OnRecvPacket defines a rpc handler method for MsgOnRecvPacket.
	// Proofs:
	// - exists: packet commitment
	// - exists: packet receipt OR packet recv sequence
	OnRecvPacket(context.Context, *MsgOnRecvPacket) (*MsgOnRecvPacketResponse, error)
	// OnAcknowledgementPacket defines a rpc handler method for MsgOnAcknowledgementPacket.
	OnAcknowledgementPacket(context.Context, *MsgOnAcknowledgementPacket) (*MsgOnAcknowledgementPacketResponse, error)
	// OnTimeoutPacket defines a rpc handler method for MsgOnTimeoutPacket.
	OnTimeoutPacket(context.Context, *MsgOnTimeoutPacket) (*MsgOnTimeoutPacketResponse, error)
}

// UnimplementedVirtualIBCChainServer can be embedded to have forward compatible implementations.
type UnimplementedVirtualIBCChainServer struct {
}

func (*UnimplementedVirtualIBCChainServer) OnChanOpenInit(ctx context.Context, req *MsgOnChanOpenInit) (*MsgOnChanOpenInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenInit not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenTry(ctx context.Context, req *MsgOnChanOpenTry) (*MsgOnChanOpenTryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenTry not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenAck(ctx context.Context, req *MsgOnChanOpenAck) (*MsgOnChanOpenAckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenAck not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenConfirm(ctx context.Context, req *MsgOnChanOpenConfirm) (*MsgOnChanOpenConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenConfirm not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnRecvPacket(ctx context.Context, req *MsgOnRecvPacket) (*MsgOnRecvPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnRecvPacket not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnAcknowledgementPacket(ctx context.Context, req *MsgOnAcknowledgementPacket) (*MsgOnAcknowledgementPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnAcknowledgementPacket not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnTimeoutPacket(ctx context.Context, req *MsgOnTimeoutPacket) (*MsgOnTimeoutPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnTimeoutPacket not implemented")
}

func RegisterVirtualIBCChainServer(s grpc1.Server, srv VirtualIBCChainServer) {
	s.RegisterService(&_VirtualIBCChain_serviceDesc, srv)
}

func _VirtualIBCChain_OnChanOpenInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenInit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenInit(ctx, req.(*MsgOnChanOpenInit))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenTry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenTry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenTry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenTry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenTry(ctx, req.(*MsgOnChanOpenTry))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenAck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenAck(ctx, req.(*MsgOnChanOpenAck))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenConfirm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenConfirm(ctx, req.(*MsgOnChanOpenConfirm))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnRecvPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnRecvPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnRecvPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnRecvPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnRecvPacket(ctx, req.(*MsgOnRecvPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnAcknowledgementPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnAcknowledgementPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnAcknowledgementPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnAcknowledgementPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnAcknowledgementPacket(ctx, req.(*MsgOnAcknowledgementPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnTimeoutPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnTimeoutPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnTimeoutPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnTimeoutPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnTimeoutPacket(ctx, req.(*MsgOnTimeoutPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualIBCChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.core.vibc.v1.VirtualIBCChain",
	HandlerType: (*VirtualIBCChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnChanOpenInit",
			Handler:    _VirtualIBCChain_OnChanOpenInit_Handler,
		},
		{
			MethodName: "OnChanOpenTry",
			Handler:    _VirtualIBCChain_OnChanOpenTry_Handler,
		},
		{
			MethodName: "OnChanOpenAck",
			Handler:    _VirtualIBCChain_OnChanOpenAck_Handler,
		},
		{
			MethodName: "OnChanOpenConfirm",
			Handler:    _VirtualIBCChain_OnChanOpenConfirm_Handler,
		},
		{
			MethodName: "OnRecvPacket",
			Handler:    _VirtualIBCChain_OnRecvPacket_Handler,
		},
		{
			MethodName: "OnAcknowledgementPacket",
			Handler:    _VirtualIBCChain_OnAcknowledgementPacket_Handler,
		},
		{
			MethodName: "OnTimeoutPacket",
			Handler:    _VirtualIBCChain_OnTimeoutPacket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/core/vibc/v1/tx.proto",
}

// VirtualIBCClient is the client API for VirtualIBC service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VirtualIBCClient interface {
	// PostChannelOpenInitOrTry defines a rpc handler method for MsgPostChannelOpenInitOrTry.
	PostChannelOpenInitOrTry(ctx context.Context, in *MsgPostChannelOpenInitOrTry, opts ...grpc.CallOption) (*MsgPostChannelOpenInitOrTryResponse, error)
	// PostChannelOpenAck defines a rpc handler method for MsgPostChannelOpenAck.
	PostChannelOpenAck(ctx context.Context, in *MsgPostChannelOpenAck, opts ...grpc.CallOption) (*MsgPostChannelOpenAckResponse, error)
	// PostChannelOpenConfirm defines a rpc handler method for MsgPostChannelOpenConfirm.
	PostChannelOpenConfirm(ctx context.Context, in *MsgPostChannelOpenConfirm, opts ...grpc.CallOption) (*MsgPostChannelOpenConfirmResponse, error)
	// The chain is also active in the initiation of the packet lifecycle.
	// SendPacket defines a rpc handler method for MsgSendPacket.
	SendPacket(ctx context.Context, in *MsgSendPacket, opts ...grpc.CallOption) (*MsgSendPacketResponse, error)
	// PostRecvPacket defines a rpc handler method for MsgPostRecvPacket.
	// This completes the RecvPacket flow.
	PostRecvPacket(ctx context.Context, in *MsgPostRecvPacket, opts ...grpc.CallOption) (*MsgPostRecvPacketResponse, error)
	// PostAcknowledgementPacket defines a rpc handler method for MsgPostAcknowledgementPacket.
	// This completes the Acknowledgement flow.
	PostAcknowledgementPacket(ctx context.Context, in *MsgPostAcknowledgementPacket, opts ...grpc.CallOption) (*MsgPostAcknowledgementPacketResponse, error)
	// PostTimeoutPacket defines a rpc handler method for MsgPostTimeoutPacket.
	// This completes the Acknowledgement flow.
	PostTimeoutPacket(ctx context.Context, in *MsgPostTimeoutPacket, opts ...grpc.CallOption) (*MsgPostTimeoutPacketResponse, error)
}

type virtualIBCClient struct {
	cc grpc1.ClientConn
}

func NewVirtualIBCClient(cc grpc1.ClientConn) VirtualIBCClient {
	return &virtualIBCClient{cc}
}

func (c *virtualIBCClient) PostChannelOpenInitOrTry(ctx context.Context, in *MsgPostChannelOpenInitOrTry, opts ...grpc.CallOption) (*MsgPostChannelOpenInitOrTryResponse, error) {
	out := new(MsgPostChannelOpenInitOrTryResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/PostChannelOpenInitOrTry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCClient) PostChannelOpenAck(ctx context.Context, in *MsgPostChannelOpenAck, opts ...grpc.CallOption) (*MsgPostChannelOpenAckResponse, error) {
	out := new(MsgPostChannelOpenAckResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/PostChannelOpenAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCClient) PostChannelOpenConfirm(ctx context.Context, in *MsgPostChannelOpenConfirm, opts ...grpc.CallOption) (*MsgPostChannelOpenConfirmResponse, error) {
	out := new(MsgPostChannelOpenConfirmResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/PostChannelOpenConfirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCClient) SendPacket(ctx context.Context, in *MsgSendPacket, opts ...grpc.CallOption) (*MsgSendPacketResponse, error) {
	out := new(MsgSendPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/SendPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCClient) PostRecvPacket(ctx context.Context, in *MsgPostRecvPacket, opts ...grpc.CallOption) (*MsgPostRecvPacketResponse, error) {
	out := new(MsgPostRecvPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/PostRecvPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCClient) PostAcknowledgementPacket(ctx context.Context, in *MsgPostAcknowledgementPacket, opts ...grpc.CallOption) (*MsgPostAcknowledgementPacketResponse, error) {
	out := new(MsgPostAcknowledgementPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/PostAcknowledgementPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCClient) PostTimeoutPacket(ctx context.Context, in *MsgPostTimeoutPacket, opts ...grpc.CallOption) (*MsgPostTimeoutPacketResponse, error) {
	out := new(MsgPostTimeoutPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBC/PostTimeoutPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualIBCServer is the server API for VirtualIBC service.
type VirtualIBCServer interface {
	// PostChannelOpenInitOrTry defines a rpc handler method for MsgPostChannelOpenInitOrTry.
	PostChannelOpenInitOrTry(context.Context, *MsgPostChannelOpenInitOrTry) (*MsgPostChannelOpenInitOrTryResponse, error)
	// PostChannelOpenAck defines a rpc handler method for MsgPostChannelOpenAck.
	PostChannelOpenAck(context.Context, *MsgPostChannelOpenAck) (*MsgPostChannelOpenAckResponse, error)
	// PostChannelOpenConfirm defines a rpc handler method for MsgPostChannelOpenConfirm.
	PostChannelOpenConfirm(context.Context, *MsgPostChannelOpenConfirm) (*MsgPostChannelOpenConfirmResponse, error)
	// The chain is also active in the initiation of the packet lifecycle.
	// SendPacket defines a rpc handler method for MsgSendPacket.
	SendPacket(context.Context, *MsgSendPacket) (*MsgSendPacketResponse, error)
	// PostRecvPacket defines a rpc handler method for MsgPostRecvPacket.
	// This completes the RecvPacket flow.
	PostRecvPacket(context.Context, *MsgPostRecvPacket) (*MsgPostRecvPacketResponse, error)
	// PostAcknowledgementPacket defines a rpc handler method for MsgPostAcknowledgementPacket.
	// This completes the Acknowledgement flow.
	PostAcknowledgementPacket(context.Context, *MsgPostAcknowledgementPacket) (*MsgPostAcknowledgementPacketResponse, error)
	// PostTimeoutPacket defines a rpc handler method for MsgPostTimeoutPacket.
	// This completes the Acknowledgement flow.
	PostTimeoutPacket(context.Context, *MsgPostTimeoutPacket) (*MsgPostTimeoutPacketResponse, error)
}

// UnimplementedVirtualIBCServer can be embedded to have forward compatible implementations.
type UnimplementedVirtualIBCServer struct {
}

func (*UnimplementedVirtualIBCServer) PostChannelOpenInitOrTry(ctx context.Context, req *MsgPostChannelOpenInitOrTry) (*MsgPostChannelOpenInitOrTryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostChannelOpenInitOrTry not implemented")
}
func (*UnimplementedVirtualIBCServer) PostChannelOpenAck(ctx context.Context, req *MsgPostChannelOpenAck) (*MsgPostChannelOpenAckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostChannelOpenAck not implemented")
}
func (*UnimplementedVirtualIBCServer) PostChannelOpenConfirm(ctx context.Context, req *MsgPostChannelOpenConfirm) (*MsgPostChannelOpenConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostChannelOpenConfirm not implemented")
}
func (*UnimplementedVirtualIBCServer) SendPacket(ctx context.Context, req *MsgSendPacket) (*MsgSendPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPacket not implemented")
}
func (*UnimplementedVirtualIBCServer) PostRecvPacket(ctx context.Context, req *MsgPostRecvPacket) (*MsgPostRecvPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostRecvPacket not implemented")
}
func (*UnimplementedVirtualIBCServer) PostAcknowledgementPacket(ctx context.Context, req *MsgPostAcknowledgementPacket) (*MsgPostAcknowledgementPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostAcknowledgementPacket not implemented")
}
func (*UnimplementedVirtualIBCServer) PostTimeoutPacket(ctx context.Context, req *MsgPostTimeoutPacket) (*MsgPostTimeoutPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PostTimeoutPacket not implemented")
}

func RegisterVirtualIBCServer(s grpc1.Server, srv VirtualIBCServer) {
	s.RegisterService(&_VirtualIBC_serviceDesc, srv)
}

func _VirtualIBC_PostChannelOpenInitOrTry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPostChannelOpenInitOrTry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).PostChannelOpenInitOrTry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/PostChannelOpenInitOrTry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).PostChannelOpenInitOrTry(ctx, req.(*MsgPostChannelOpenInitOrTry))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBC_PostChannelOpenAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPostChannelOpenAck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).PostChannelOpenAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/PostChannelOpenAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).PostChannelOpenAck(ctx, req.(*MsgPostChannelOpenAck))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBC_PostChannelOpenConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPostChannelOpenConfirm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).PostChannelOpenConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/PostChannelOpenConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).PostChannelOpenConfirm(ctx, req.(*MsgPostChannelOpenConfirm))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBC_SendPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).SendPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/SendPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).SendPacket(ctx, req.(*MsgSendPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBC_PostRecvPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPostRecvPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).PostRecvPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/PostRecvPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).PostRecvPacket(ctx, req.(*MsgPostRecvPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBC_PostAcknowledgementPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPostAcknowledgementPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).PostAcknowledgementPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/PostAcknowledgementPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).PostAcknowledgementPacket(ctx, req.(*MsgPostAcknowledgementPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBC_PostTimeoutPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgPostTimeoutPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCServer).PostTimeoutPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBC/PostTimeoutPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCServer).PostTimeoutPacket(ctx, req.(*MsgPostTimeoutPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualIBC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.core.vibc.v1.VirtualIBC",
	HandlerType: (*VirtualIBCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PostChannelOpenInitOrTry",
			Handler:    _VirtualIBC_PostChannelOpenInitOrTry_Handler,
		},
		{
			MethodName: "PostChannelOpenAck",
			Handler:    _VirtualIBC_PostChannelOpenAck_Handler,
		},
		{
			MethodName: "PostChannelOpenConfirm",
			Handler:    _VirtualIBC_PostChannelOpenConfirm_Handler,
		},
		{
			MethodName: "SendPacket",
			Handler:    _VirtualIBC_SendPacket_Handler,
		},
		{
			MethodName: "PostRecvPacket",
			Handler:    _VirtualIBC_PostRecvPacket_Handler,
		},
		{
			MethodName: "PostAcknowledgementPacket",
			Handler:    _VirtualIBC_PostAcknowledgementPacket_Handler,
		},
		{
			MethodName: "PostTimeoutPacket",
			Handler:    _VirtualIBC_PostTimeoutPacket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/core/vibc/v1/tx.proto",
}

func (m *MsgSendPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeoutTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TimeoutTimestamp))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.TimeoutHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceChannelId) > 0 {
		i -= len(m.SourceChannelId)
		copy(dAtA[i:], m.SourceChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourcePortId) > 0 {
		i -= len(m.SourcePortId)
		copy(dAtA[i:], m.SourcePortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourcePortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenTry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenTry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenTry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenTryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenTryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenTryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CounterpartyChannelId) > 0 {
		i -= len(m.CounterpartyChannelId)
		copy(dAtA[i:], m.CounterpartyChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenAckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenAckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenAckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenConfirmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenConfirmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenConfirmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPostChannelOpenInitOrTry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostChannelOpenInitOrTry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostChannelOpenInitOrTry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPostChannelOpenInitOrTryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostChannelOpenInitOrTryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostChannelOpenInitOrTryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPostChannelOpenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostChannelOpenAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostChannelOpenAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CounterpartyChannelId) > 0 {
		i -= len(m.CounterpartyChannelId)
		copy(dAtA[i:], m.CounterpartyChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPostChannelOpenAckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostChannelOpenAckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostChannelOpenAckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPostChannelOpenConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostChannelOpenConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostChannelOpenConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgPostChannelOpenConfirmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostChannelOpenConfirmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostChannelOpenConfirmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnRecvPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnRecvPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnRecvPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnRecvPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnRecvPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnRecvPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnTimeoutPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnTimeoutPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnTimeoutPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnTimeoutPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnTimeoutPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnTimeoutPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnAcknowledgementPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnAcknowledgementPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnAcknowledgementPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Acknowledgement) > 0 {
		i -= len(m.Acknowledgement)
		copy(dAtA[i:], m.Acknowledgement)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Acknowledgement)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnAcknowledgementPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnAcknowledgementPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnAcknowledgementPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPostRecvPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostRecvPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostRecvPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Acknowledgement != nil {
		{
			size, err := m.Acknowledgement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPostRecvPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostRecvPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostRecvPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPostAcknowledgementPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostAcknowledgementPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostAcknowledgementPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPostAcknowledgementPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostAcknowledgementPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostAcknowledgementPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgPostTimeoutPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostTimeoutPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostTimeoutPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgPostTimeoutPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPostTimeoutPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPostTimeoutPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgSendPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourcePortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.TimeoutHeight.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.TimeoutTimestamp != 0 {
		n += 1 + sovTx(uint64(m.TimeoutTimestamp))
	}
	return n
}

func (m *MsgSendPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovTx(uint64(m.Sequence))
	}
	return n
}

func (m *MsgOnChanOpenInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnChanOpenTry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenTryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnChanOpenAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenAckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnChanOpenConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenConfirmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPostChannelOpenInitOrTry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPostChannelOpenInitOrTryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPostChannelOpenAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPostChannelOpenAckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPostChannelOpenConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPostChannelOpenConfirmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnRecvPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnRecvPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnTimeoutPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnTimeoutPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnAcknowledgementPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Acknowledgement)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnAcknowledgementPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPostRecvPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Acknowledgement != nil {
		l = m.Acknowledgement.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgPostRecvPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPostAcknowledgementPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPostAcknowledgementPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgPostTimeoutPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgPostTimeoutPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgSendPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeoutHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTimestamp", wireType)
			}
			m.TimeoutTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &types1.Channel{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenTry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenTry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenTry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &types1.Channel{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenTryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenTryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenTryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenAckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenAckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenAckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenConfirmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostChannelOpenInitOrTry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostChannelOpenInitOrTry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostChannelOpenInitOrTry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &types1.Channel{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostChannelOpenInitOrTryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostChannelOpenInitOrTryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostChannelOpenInitOrTryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostChannelOpenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostChannelOpenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostChannelOpenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostChannelOpenAckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostChannelOpenAckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostChannelOpenAckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostChannelOpenConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostChannelOpenConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostChannelOpenConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostChannelOpenConfirmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostChannelOpenConfirmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostChannelOpenConfirmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnRecvPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnRecvPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnRecvPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnRecvPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnRecvPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnRecvPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnTimeoutPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnTimeoutPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnTimeoutPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnTimeoutPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnTimeoutPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnTimeoutPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnAcknowledgementPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledgement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acknowledgement = append(m.Acknowledgement[:0], dAtA[iNdEx:postIndex]...)
			if m.Acknowledgement == nil {
				m.Acknowledgement = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnAcknowledgementPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostRecvPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostRecvPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostRecvPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledgement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledgement == nil {
				m.Acknowledgement = &types1.Acknowledgement{}
			}
			if err := m.Acknowledgement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostRecvPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostRecvPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostRecvPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostAcknowledgementPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostAcknowledgementPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostAcknowledgementPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostAcknowledgementPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostAcknowledgementPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostAcknowledgementPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostTimeoutPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostTimeoutPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostTimeoutPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPostTimeoutPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPostTimeoutPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPostTimeoutPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
