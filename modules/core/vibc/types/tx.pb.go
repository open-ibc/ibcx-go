// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/core/vibc/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/cosmos/ibc-go/v7/modules/core/02-client/types"
	types1 "github.com/cosmos/ibc-go/v7/modules/core/04-channel/types"
	_ "github.com/cosmos/ibc-go/v7/modules/core/23-commitment/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgSendPacket defines an sdk.Msg to send a packet.
// It is initiated by the vIBC chain side.
type MsgSendPacket struct {
	SourcePortId    string `protobuf:"bytes,1,opt,name=source_port_id,json=sourcePortId,proto3" json:"source_port_id,omitempty" yaml:"source_port_id"`
	SourceChannelId string `protobuf:"bytes,2,opt,name=source_channel_id,json=sourceChannelId,proto3" json:"source_channel_id,omitempty" yaml:"source_channel_id"`
	Data            []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty" yaml:"data"`
	// Timeout height relative to the current block height.
	// The timeout is disabled when set to 0.
	TimeoutHeight types.Height `protobuf:"bytes,4,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height" yaml:"timeout_height"`
	// Timeout timestamp in absolute nanoseconds since unix epoch.
	// The timeout is disabled when set to 0.
	TimeoutTimestamp uint64 `protobuf:"varint,5,opt,name=timeout_timestamp,json=timeoutTimestamp,proto3" json:"timeout_timestamp,omitempty" yaml:"timeout_timestamp"`
}

func (m *MsgSendPacket) Reset()         { *m = MsgSendPacket{} }
func (m *MsgSendPacket) String() string { return proto.CompactTextString(m) }
func (*MsgSendPacket) ProtoMessage()    {}
func (*MsgSendPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{0}
}
func (m *MsgSendPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendPacket.Merge(m, src)
}
func (m *MsgSendPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendPacket proto.InternalMessageInfo

// MsgSendPacketResponse defines an sdk.Msg for a send packet response.
// It is returned by the vIBC sidecar side.
type MsgSendPacketResponse struct {
	Sequence uint64 `protobuf:"varint,1,opt,name=sequence,proto3" json:"sequence,omitempty" yaml:"sequence"`
}

func (m *MsgSendPacketResponse) Reset()         { *m = MsgSendPacketResponse{} }
func (m *MsgSendPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendPacketResponse) ProtoMessage()    {}
func (*MsgSendPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{1}
}
func (m *MsgSendPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendPacketResponse.Merge(m, src)
}
func (m *MsgSendPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendPacketResponse proto.InternalMessageInfo

func (m *MsgSendPacketResponse) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

// MsgOnChanOpenInit defines an sdk.Msg to for a channel init callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenInit struct {
	PortId    string          `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string          `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Channel   *types1.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
}

func (m *MsgOnChanOpenInit) Reset()         { *m = MsgOnChanOpenInit{} }
func (m *MsgOnChanOpenInit) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenInit) ProtoMessage()    {}
func (*MsgOnChanOpenInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{2}
}
func (m *MsgOnChanOpenInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenInit.Merge(m, src)
}
func (m *MsgOnChanOpenInit) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenInit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenInit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenInit proto.InternalMessageInfo

// MsgOnChanOpenInitResponse defines the Msg/OnChanOpenInit response type.
type MsgOnChanOpenInitResponse struct {
}

func (m *MsgOnChanOpenInitResponse) Reset()         { *m = MsgOnChanOpenInitResponse{} }
func (m *MsgOnChanOpenInitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenInitResponse) ProtoMessage()    {}
func (*MsgOnChanOpenInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{3}
}
func (m *MsgOnChanOpenInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenInitResponse.Merge(m, src)
}
func (m *MsgOnChanOpenInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenInitResponse proto.InternalMessageInfo

// MsgOnChanOpenTry defines an sdk.Msg to for a channel open try callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenTry struct {
	PortId              string          `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId           string          `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Channel             *types1.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
	CounterpartyVersion string          `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgOnChanOpenTry) Reset()         { *m = MsgOnChanOpenTry{} }
func (m *MsgOnChanOpenTry) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenTry) ProtoMessage()    {}
func (*MsgOnChanOpenTry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{4}
}
func (m *MsgOnChanOpenTry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenTry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenTry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenTry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenTry.Merge(m, src)
}
func (m *MsgOnChanOpenTry) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenTry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenTry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenTry proto.InternalMessageInfo

// MsgOnChanOpenTryResponse defines the Msg/OnChanOpenTry response type.
type MsgOnChanOpenTryResponse struct {
}

func (m *MsgOnChanOpenTryResponse) Reset()         { *m = MsgOnChanOpenTryResponse{} }
func (m *MsgOnChanOpenTryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenTryResponse) ProtoMessage()    {}
func (*MsgOnChanOpenTryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{5}
}
func (m *MsgOnChanOpenTryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenTryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenTryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenTryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenTryResponse.Merge(m, src)
}
func (m *MsgOnChanOpenTryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenTryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenTryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenTryResponse proto.InternalMessageInfo

// MsgOnChanOpenAck defines an sdk.Msg to for a channel open ack callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenAck struct {
	PortId                string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId             string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	CounterpartyChannelId string `protobuf:"bytes,3,opt,name=counterparty_channel_id,json=counterpartyChannelId,proto3" json:"counterparty_channel_id,omitempty" yaml:"counterparty_channel_id"`
	CounterpartyVersion   string `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgOnChanOpenAck) Reset()         { *m = MsgOnChanOpenAck{} }
func (m *MsgOnChanOpenAck) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenAck) ProtoMessage()    {}
func (*MsgOnChanOpenAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{6}
}
func (m *MsgOnChanOpenAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenAck.Merge(m, src)
}
func (m *MsgOnChanOpenAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenAck proto.InternalMessageInfo

// MsgOnChanOpenAckResponse defines the Msg/OnChanOpenAck response type.
type MsgOnChanOpenAckResponse struct {
}

func (m *MsgOnChanOpenAckResponse) Reset()         { *m = MsgOnChanOpenAckResponse{} }
func (m *MsgOnChanOpenAckResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenAckResponse) ProtoMessage()    {}
func (*MsgOnChanOpenAckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{7}
}
func (m *MsgOnChanOpenAckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenAckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenAckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenAckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenAckResponse.Merge(m, src)
}
func (m *MsgOnChanOpenAckResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenAckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenAckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenAckResponse proto.InternalMessageInfo

// MsgOnChanOpenConfirm defines an sdk.Msg to for a channel open Confirm callbConfirm.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenConfirm struct {
	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
}

func (m *MsgOnChanOpenConfirm) Reset()         { *m = MsgOnChanOpenConfirm{} }
func (m *MsgOnChanOpenConfirm) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenConfirm) ProtoMessage()    {}
func (*MsgOnChanOpenConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{8}
}
func (m *MsgOnChanOpenConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenConfirm.Merge(m, src)
}
func (m *MsgOnChanOpenConfirm) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenConfirm proto.InternalMessageInfo

// MsgOnChanOpenConfirmResponse defines the Msg/OnChanOpenConfirm response type.
type MsgOnChanOpenConfirmResponse struct {
}

func (m *MsgOnChanOpenConfirmResponse) Reset()         { *m = MsgOnChanOpenConfirmResponse{} }
func (m *MsgOnChanOpenConfirmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenConfirmResponse) ProtoMessage()    {}
func (*MsgOnChanOpenConfirmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{9}
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenConfirmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenConfirmResponse.Merge(m, src)
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenConfirmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenConfirmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenConfirmResponse proto.InternalMessageInfo

// MsgWriteOpenInitOrTryChan defines an sdk.Msg for the completion of INIT/TRY channel.
// It originates from the vIBC chain side.
type MsgWriteOpenInitOrTryChan struct {
	PortId    string          `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string          `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Channel   *types1.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel,omitempty"`
}

func (m *MsgWriteOpenInitOrTryChan) Reset()         { *m = MsgWriteOpenInitOrTryChan{} }
func (m *MsgWriteOpenInitOrTryChan) String() string { return proto.CompactTextString(m) }
func (*MsgWriteOpenInitOrTryChan) ProtoMessage()    {}
func (*MsgWriteOpenInitOrTryChan) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{10}
}
func (m *MsgWriteOpenInitOrTryChan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWriteOpenInitOrTryChan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWriteOpenInitOrTryChan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWriteOpenInitOrTryChan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWriteOpenInitOrTryChan.Merge(m, src)
}
func (m *MsgWriteOpenInitOrTryChan) XXX_Size() int {
	return m.Size()
}
func (m *MsgWriteOpenInitOrTryChan) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWriteOpenInitOrTryChan.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWriteOpenInitOrTryChan proto.InternalMessageInfo

// MsgWriteOpenInitOrTryChanResponse defines the Msg/WriteOpenInitOrTryChan response type.
type MsgWriteOpenInitOrTryChanResponse struct {
}

func (m *MsgWriteOpenInitOrTryChanResponse) Reset()         { *m = MsgWriteOpenInitOrTryChanResponse{} }
func (m *MsgWriteOpenInitOrTryChanResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWriteOpenInitOrTryChanResponse) ProtoMessage()    {}
func (*MsgWriteOpenInitOrTryChanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{11}
}
func (m *MsgWriteOpenInitOrTryChanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWriteOpenInitOrTryChanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWriteOpenInitOrTryChanResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWriteOpenInitOrTryChanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWriteOpenInitOrTryChanResponse.Merge(m, src)
}
func (m *MsgWriteOpenInitOrTryChanResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWriteOpenInitOrTryChanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWriteOpenInitOrTryChanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWriteOpenInitOrTryChanResponse proto.InternalMessageInfo

// MsgWriteOpenAckChan defines an sdk.Msg for the completion of ACK channel.
// It originates from the vIBC chain side.
type MsgWriteOpenAckChan struct {
	PortId                string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId             string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	CounterpartyChannelId string `protobuf:"bytes,3,opt,name=counterparty_channel_id,json=counterpartyChannelId,proto3" json:"counterparty_channel_id,omitempty" yaml:"counterparty_channel_id"`
	CounterpartyVersion   string `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgWriteOpenAckChan) Reset()         { *m = MsgWriteOpenAckChan{} }
func (m *MsgWriteOpenAckChan) String() string { return proto.CompactTextString(m) }
func (*MsgWriteOpenAckChan) ProtoMessage()    {}
func (*MsgWriteOpenAckChan) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{12}
}
func (m *MsgWriteOpenAckChan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWriteOpenAckChan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWriteOpenAckChan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWriteOpenAckChan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWriteOpenAckChan.Merge(m, src)
}
func (m *MsgWriteOpenAckChan) XXX_Size() int {
	return m.Size()
}
func (m *MsgWriteOpenAckChan) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWriteOpenAckChan.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWriteOpenAckChan proto.InternalMessageInfo

// MsgWriteOpenAckChanResponse defines the Msg/WriteOpenAckChan response type.
type MsgWriteOpenAckChanResponse struct {
}

func (m *MsgWriteOpenAckChanResponse) Reset()         { *m = MsgWriteOpenAckChanResponse{} }
func (m *MsgWriteOpenAckChanResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWriteOpenAckChanResponse) ProtoMessage()    {}
func (*MsgWriteOpenAckChanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{13}
}
func (m *MsgWriteOpenAckChanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWriteOpenAckChanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWriteOpenAckChanResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWriteOpenAckChanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWriteOpenAckChanResponse.Merge(m, src)
}
func (m *MsgWriteOpenAckChanResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWriteOpenAckChanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWriteOpenAckChanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWriteOpenAckChanResponse proto.InternalMessageInfo

// MsgWriteOpenConfirmChan defines an sdk.Msg for the completion of CONFIRM channel.
// It originates from the vIBC chain side.
type MsgWriteOpenConfirmChan struct {
	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
}

func (m *MsgWriteOpenConfirmChan) Reset()         { *m = MsgWriteOpenConfirmChan{} }
func (m *MsgWriteOpenConfirmChan) String() string { return proto.CompactTextString(m) }
func (*MsgWriteOpenConfirmChan) ProtoMessage()    {}
func (*MsgWriteOpenConfirmChan) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{14}
}
func (m *MsgWriteOpenConfirmChan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWriteOpenConfirmChan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWriteOpenConfirmChan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWriteOpenConfirmChan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWriteOpenConfirmChan.Merge(m, src)
}
func (m *MsgWriteOpenConfirmChan) XXX_Size() int {
	return m.Size()
}
func (m *MsgWriteOpenConfirmChan) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWriteOpenConfirmChan.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWriteOpenConfirmChan proto.InternalMessageInfo

// MsgWriteOpenConfirmChanResponse defines the Msg/WriteOpenConfirmChan response type.
type MsgWriteOpenConfirmChanResponse struct {
}

func (m *MsgWriteOpenConfirmChanResponse) Reset()         { *m = MsgWriteOpenConfirmChanResponse{} }
func (m *MsgWriteOpenConfirmChanResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWriteOpenConfirmChanResponse) ProtoMessage()    {}
func (*MsgWriteOpenConfirmChanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{15}
}
func (m *MsgWriteOpenConfirmChanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWriteOpenConfirmChanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWriteOpenConfirmChanResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWriteOpenConfirmChanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWriteOpenConfirmChanResponse.Merge(m, src)
}
func (m *MsgWriteOpenConfirmChanResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWriteOpenConfirmChanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWriteOpenConfirmChanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWriteOpenConfirmChanResponse proto.InternalMessageInfo

// MsgOnRecvPacket defines an sdk.Msg to for a packet receipt.
// It originates from the vIBC sidecar side.
type MsgOnRecvPacket struct {
	Packet  types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Relayer string        `protobuf:"bytes,2,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnRecvPacket) Reset()         { *m = MsgOnRecvPacket{} }
func (m *MsgOnRecvPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnRecvPacket) ProtoMessage()    {}
func (*MsgOnRecvPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{16}
}
func (m *MsgOnRecvPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnRecvPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnRecvPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnRecvPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnRecvPacket.Merge(m, src)
}
func (m *MsgOnRecvPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnRecvPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnRecvPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnRecvPacket proto.InternalMessageInfo

// MsgOnRecvPacketResponse defines the Msg/OnRecvPacket response type.
type MsgOnRecvPacketResponse struct {
}

func (m *MsgOnRecvPacketResponse) Reset()         { *m = MsgOnRecvPacketResponse{} }
func (m *MsgOnRecvPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnRecvPacketResponse) ProtoMessage()    {}
func (*MsgOnRecvPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{17}
}
func (m *MsgOnRecvPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnRecvPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnRecvPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnRecvPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnRecvPacketResponse.Merge(m, src)
}
func (m *MsgOnRecvPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnRecvPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnRecvPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnRecvPacketResponse proto.InternalMessageInfo

// MsgOnTimeoutPacket defines an sdk.Msg to for a packet receipt.
// It originates from the vIBC sidecar side.
type MsgOnTimeoutPacket struct {
	Packet  types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Relayer string        `protobuf:"bytes,2,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnTimeoutPacket) Reset()         { *m = MsgOnTimeoutPacket{} }
func (m *MsgOnTimeoutPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnTimeoutPacket) ProtoMessage()    {}
func (*MsgOnTimeoutPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{18}
}
func (m *MsgOnTimeoutPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnTimeoutPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnTimeoutPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnTimeoutPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnTimeoutPacket.Merge(m, src)
}
func (m *MsgOnTimeoutPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnTimeoutPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnTimeoutPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnTimeoutPacket proto.InternalMessageInfo

// MsgOnTimeoutPacketResponse defines the Msg/OnTimeoutPacket response type.
type MsgOnTimeoutPacketResponse struct {
}

func (m *MsgOnTimeoutPacketResponse) Reset()         { *m = MsgOnTimeoutPacketResponse{} }
func (m *MsgOnTimeoutPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnTimeoutPacketResponse) ProtoMessage()    {}
func (*MsgOnTimeoutPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{19}
}
func (m *MsgOnTimeoutPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnTimeoutPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnTimeoutPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnTimeoutPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnTimeoutPacketResponse.Merge(m, src)
}
func (m *MsgOnTimeoutPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnTimeoutPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnTimeoutPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnTimeoutPacketResponse proto.InternalMessageInfo

// MsgOnAcknowledgementPacket defines an sdk.Msg to for a packet acknowledgement.
// It originates from the vIBC sidecar side.
type MsgOnAcknowledgementPacket struct {
	Packet          types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Acknowledgement []byte        `protobuf:"bytes,2,opt,name=acknowledgement,proto3" json:"acknowledgement,omitempty"`
	Relayer         string        `protobuf:"bytes,3,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnAcknowledgementPacket) Reset()         { *m = MsgOnAcknowledgementPacket{} }
func (m *MsgOnAcknowledgementPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnAcknowledgementPacket) ProtoMessage()    {}
func (*MsgOnAcknowledgementPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{20}
}
func (m *MsgOnAcknowledgementPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnAcknowledgementPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnAcknowledgementPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnAcknowledgementPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnAcknowledgementPacket.Merge(m, src)
}
func (m *MsgOnAcknowledgementPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnAcknowledgementPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnAcknowledgementPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnAcknowledgementPacket proto.InternalMessageInfo

// MsgOnAcknowledgementPacketResponse defines the Msg/OnAcknowledgementPacket response type.
type MsgOnAcknowledgementPacketResponse struct {
}

func (m *MsgOnAcknowledgementPacketResponse) Reset()         { *m = MsgOnAcknowledgementPacketResponse{} }
func (m *MsgOnAcknowledgementPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnAcknowledgementPacketResponse) ProtoMessage()    {}
func (*MsgOnAcknowledgementPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{21}
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnAcknowledgementPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnAcknowledgementPacketResponse.Merge(m, src)
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnAcknowledgementPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnAcknowledgementPacketResponse proto.InternalMessageInfo

// MsgWritePacketAck defines an sdk.Msg to for writing a packet acknowledgement.
// It originates from the vIBC chain side.
type MsgWritePacketAck struct {
	Packet          types1.Packet           `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Acknowledgement *types1.Acknowledgement `protobuf:"bytes,2,opt,name=acknowledgement,proto3" json:"acknowledgement,omitempty"`
}

func (m *MsgWritePacketAck) Reset()         { *m = MsgWritePacketAck{} }
func (m *MsgWritePacketAck) String() string { return proto.CompactTextString(m) }
func (*MsgWritePacketAck) ProtoMessage()    {}
func (*MsgWritePacketAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{22}
}
func (m *MsgWritePacketAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWritePacketAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWritePacketAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWritePacketAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWritePacketAck.Merge(m, src)
}
func (m *MsgWritePacketAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgWritePacketAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWritePacketAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWritePacketAck proto.InternalMessageInfo

type MsgWritePacketAckResponse struct {
}

func (m *MsgWritePacketAckResponse) Reset()         { *m = MsgWritePacketAckResponse{} }
func (m *MsgWritePacketAckResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWritePacketAckResponse) ProtoMessage()    {}
func (*MsgWritePacketAckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{23}
}
func (m *MsgWritePacketAckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWritePacketAckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWritePacketAckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWritePacketAckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWritePacketAckResponse.Merge(m, src)
}
func (m *MsgWritePacketAckResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWritePacketAckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWritePacketAckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWritePacketAckResponse proto.InternalMessageInfo

// MsgEmitAckPacketEvent defines an sdk.Msg to for emitting a packet acknowledgement event.
// It originates from the vIBC chain side.
type MsgEmitAckPacketEvent struct {
	Packet types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
}

func (m *MsgEmitAckPacketEvent) Reset()         { *m = MsgEmitAckPacketEvent{} }
func (m *MsgEmitAckPacketEvent) String() string { return proto.CompactTextString(m) }
func (*MsgEmitAckPacketEvent) ProtoMessage()    {}
func (*MsgEmitAckPacketEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{24}
}
func (m *MsgEmitAckPacketEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmitAckPacketEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmitAckPacketEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmitAckPacketEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmitAckPacketEvent.Merge(m, src)
}
func (m *MsgEmitAckPacketEvent) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmitAckPacketEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmitAckPacketEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmitAckPacketEvent proto.InternalMessageInfo

type MsgEmitAckPacketEventResponse struct {
}

func (m *MsgEmitAckPacketEventResponse) Reset()         { *m = MsgEmitAckPacketEventResponse{} }
func (m *MsgEmitAckPacketEventResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEmitAckPacketEventResponse) ProtoMessage()    {}
func (*MsgEmitAckPacketEventResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{25}
}
func (m *MsgEmitAckPacketEventResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmitAckPacketEventResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmitAckPacketEventResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmitAckPacketEventResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmitAckPacketEventResponse.Merge(m, src)
}
func (m *MsgEmitAckPacketEventResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmitAckPacketEventResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmitAckPacketEventResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmitAckPacketEventResponse proto.InternalMessageInfo

// MsgEmitTimeoutPacketEvent defines an sdk.Msg to for emitting a packet timeout event.
// It originates from the vIBC chain side.
type MsgEmitTimeoutPacketEvent struct {
	Packet types1.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
}

func (m *MsgEmitTimeoutPacketEvent) Reset()         { *m = MsgEmitTimeoutPacketEvent{} }
func (m *MsgEmitTimeoutPacketEvent) String() string { return proto.CompactTextString(m) }
func (*MsgEmitTimeoutPacketEvent) ProtoMessage()    {}
func (*MsgEmitTimeoutPacketEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{26}
}
func (m *MsgEmitTimeoutPacketEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmitTimeoutPacketEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmitTimeoutPacketEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmitTimeoutPacketEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmitTimeoutPacketEvent.Merge(m, src)
}
func (m *MsgEmitTimeoutPacketEvent) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmitTimeoutPacketEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmitTimeoutPacketEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmitTimeoutPacketEvent proto.InternalMessageInfo

type MsgEmitTimeoutPacketEventResponse struct {
}

func (m *MsgEmitTimeoutPacketEventResponse) Reset()         { *m = MsgEmitTimeoutPacketEventResponse{} }
func (m *MsgEmitTimeoutPacketEventResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEmitTimeoutPacketEventResponse) ProtoMessage()    {}
func (*MsgEmitTimeoutPacketEventResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{27}
}
func (m *MsgEmitTimeoutPacketEventResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEmitTimeoutPacketEventResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEmitTimeoutPacketEventResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEmitTimeoutPacketEventResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEmitTimeoutPacketEventResponse.Merge(m, src)
}
func (m *MsgEmitTimeoutPacketEventResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEmitTimeoutPacketEventResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEmitTimeoutPacketEventResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEmitTimeoutPacketEventResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgSendPacket)(nil), "ibc.core.vibc.v1.MsgSendPacket")
	proto.RegisterType((*MsgSendPacketResponse)(nil), "ibc.core.vibc.v1.MsgSendPacketResponse")
	proto.RegisterType((*MsgOnChanOpenInit)(nil), "ibc.core.vibc.v1.MsgOnChanOpenInit")
	proto.RegisterType((*MsgOnChanOpenInitResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenInitResponse")
	proto.RegisterType((*MsgOnChanOpenTry)(nil), "ibc.core.vibc.v1.MsgOnChanOpenTry")
	proto.RegisterType((*MsgOnChanOpenTryResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenTryResponse")
	proto.RegisterType((*MsgOnChanOpenAck)(nil), "ibc.core.vibc.v1.MsgOnChanOpenAck")
	proto.RegisterType((*MsgOnChanOpenAckResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenAckResponse")
	proto.RegisterType((*MsgOnChanOpenConfirm)(nil), "ibc.core.vibc.v1.MsgOnChanOpenConfirm")
	proto.RegisterType((*MsgOnChanOpenConfirmResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenConfirmResponse")
	proto.RegisterType((*MsgWriteOpenInitOrTryChan)(nil), "ibc.core.vibc.v1.MsgWriteOpenInitOrTryChan")
	proto.RegisterType((*MsgWriteOpenInitOrTryChanResponse)(nil), "ibc.core.vibc.v1.MsgWriteOpenInitOrTryChanResponse")
	proto.RegisterType((*MsgWriteOpenAckChan)(nil), "ibc.core.vibc.v1.MsgWriteOpenAckChan")
	proto.RegisterType((*MsgWriteOpenAckChanResponse)(nil), "ibc.core.vibc.v1.MsgWriteOpenAckChanResponse")
	proto.RegisterType((*MsgWriteOpenConfirmChan)(nil), "ibc.core.vibc.v1.MsgWriteOpenConfirmChan")
	proto.RegisterType((*MsgWriteOpenConfirmChanResponse)(nil), "ibc.core.vibc.v1.MsgWriteOpenConfirmChanResponse")
	proto.RegisterType((*MsgOnRecvPacket)(nil), "ibc.core.vibc.v1.MsgOnRecvPacket")
	proto.RegisterType((*MsgOnRecvPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnRecvPacketResponse")
	proto.RegisterType((*MsgOnTimeoutPacket)(nil), "ibc.core.vibc.v1.MsgOnTimeoutPacket")
	proto.RegisterType((*MsgOnTimeoutPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnTimeoutPacketResponse")
	proto.RegisterType((*MsgOnAcknowledgementPacket)(nil), "ibc.core.vibc.v1.MsgOnAcknowledgementPacket")
	proto.RegisterType((*MsgOnAcknowledgementPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnAcknowledgementPacketResponse")
	proto.RegisterType((*MsgWritePacketAck)(nil), "ibc.core.vibc.v1.MsgWritePacketAck")
	proto.RegisterType((*MsgWritePacketAckResponse)(nil), "ibc.core.vibc.v1.MsgWritePacketAckResponse")
	proto.RegisterType((*MsgEmitAckPacketEvent)(nil), "ibc.core.vibc.v1.MsgEmitAckPacketEvent")
	proto.RegisterType((*MsgEmitAckPacketEventResponse)(nil), "ibc.core.vibc.v1.MsgEmitAckPacketEventResponse")
	proto.RegisterType((*MsgEmitTimeoutPacketEvent)(nil), "ibc.core.vibc.v1.MsgEmitTimeoutPacketEvent")
	proto.RegisterType((*MsgEmitTimeoutPacketEventResponse)(nil), "ibc.core.vibc.v1.MsgEmitTimeoutPacketEventResponse")
}

func init() { proto.RegisterFile("ibc/core/vibc/v1/tx.proto", fileDescriptor_9d1a3d740386b8a9) }

var fileDescriptor_9d1a3d740386b8a9 = []byte{
	// 1194 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x4c, 0xdb, 0x56,
	0x18, 0x8f, 0x81, 0x42, 0xf9, 0xf8, 0x13, 0x62, 0xa0, 0x04, 0x03, 0x31, 0x18, 0xb6, 0xd2, 0xd1,
	0x3a, 0x02, 0xaa, 0x4d, 0xeb, 0x65, 0x22, 0xa8, 0x12, 0x1c, 0x18, 0x95, 0x8b, 0x98, 0x54, 0x55,
	0xa2, 0x8e, 0xf3, 0x96, 0x58, 0x89, 0xff, 0xcc, 0x76, 0xb2, 0xa5, 0xd2, 0x4e, 0x93, 0xa6, 0x49,
	0xbb, 0xec, 0xb6, 0x6b, 0x2f, 0x93, 0x76, 0x9b, 0xb4, 0xd3, 0x8e, 0x3b, 0xf6, 0xd8, 0xe3, 0x4e,
	0xd1, 0x04, 0x97, 0x9e, 0x73, 0xd8, 0x79, 0xf2, 0x7b, 0xce, 0xcb, 0x73, 0x6c, 0x93, 0x74, 0x9d,
	0xa2, 0xf6, 0x84, 0xf3, 0xbe, 0x9f, 0x7f, 0xdf, 0xef, 0xfb, 0xbd, 0xcf, 0x7e, 0x1f, 0x86, 0x65,
	0xbd, 0xa8, 0xe5, 0x35, 0xcb, 0x41, 0xf9, 0x86, 0x7f, 0xd5, 0xd8, 0xcd, 0x7b, 0xdf, 0xc8, 0xb6,
	0x63, 0x79, 0x16, 0x3f, 0xa7, 0x17, 0x35, 0xd9, 0x0f, 0xc9, 0x7e, 0x48, 0x6e, 0xec, 0x0a, 0x0b,
	0x65, 0xab, 0x6c, 0xe1, 0x60, 0xde, 0xbf, 0x22, 0x38, 0x41, 0xa4, 0x14, 0x5a, 0x4d, 0x47, 0xa6,
	0xe7, 0x93, 0x90, 0xab, 0x00, 0xb0, 0xd1, 0x05, 0x54, 0x54, 0xd3, 0x44, 0x35, 0x8c, 0x20, 0x97,
	0x01, 0xe4, 0x76, 0x17, 0x62, 0x19, 0x86, 0xee, 0x19, 0x1d, 0x1e, 0xfa, 0x8b, 0x00, 0xa5, 0x7f,
	0x46, 0x60, 0xe6, 0xc4, 0x2d, 0x3f, 0x46, 0x66, 0xe9, 0x91, 0xaa, 0x55, 0x91, 0xc7, 0x7f, 0x06,
	0xb3, 0xae, 0x55, 0x77, 0x34, 0x74, 0x61, 0x5b, 0x8e, 0x77, 0xa1, 0x97, 0xb2, 0xdc, 0x3a, 0xb7,
	0x3d, 0x59, 0x58, 0x6e, 0xb7, 0xc4, 0xc5, 0xa6, 0x6a, 0xd4, 0x1e, 0x48, 0xe1, 0xb8, 0xa4, 0x4c,
	0x93, 0x85, 0x47, 0x96, 0xe3, 0x1d, 0x97, 0xf8, 0x23, 0xc8, 0x04, 0x80, 0x40, 0x93, 0xcf, 0x31,
	0x82, 0x39, 0x56, 0xdb, 0x2d, 0x31, 0x1b, 0xe2, 0xe8, 0x42, 0x24, 0x25, 0x4d, 0xd6, 0x0e, 0xc9,
	0xd2, 0x71, 0x89, 0xdf, 0x84, 0xb1, 0x92, 0xea, 0xa9, 0xd9, 0xd1, 0x75, 0x6e, 0x7b, 0xba, 0x90,
	0x6e, 0xb7, 0xc4, 0x29, 0x72, 0xb3, 0xbf, 0x2a, 0x29, 0x38, 0xc8, 0x3f, 0x83, 0x59, 0x4f, 0x37,
	0x90, 0x55, 0xf7, 0x2e, 0x2a, 0x48, 0x2f, 0x57, 0xbc, 0xec, 0xd8, 0x3a, 0xb7, 0x3d, 0xb5, 0x27,
	0xc8, 0xd4, 0xef, 0xc0, 0xbd, 0xc6, 0xae, 0x7c, 0x84, 0x11, 0x85, 0xb5, 0x97, 0x2d, 0x31, 0xd5,
	0xad, 0x27, 0x7c, 0xbf, 0xa4, 0xcc, 0x04, 0x0b, 0x04, 0xcd, 0x1f, 0x43, 0xa6, 0x83, 0xf0, 0xff,
	0xba, 0x9e, 0x6a, 0xd8, 0xd9, 0x1b, 0xeb, 0xdc, 0xf6, 0x18, 0x5b, 0x50, 0x04, 0x22, 0x29, 0x73,
	0xc1, 0xda, 0x59, 0x67, 0xe9, 0xc1, 0xcd, 0x1f, 0x5e, 0x88, 0xa9, 0xd7, 0x2f, 0xc4, 0x94, 0x74,
	0x04, 0x8b, 0x21, 0xdf, 0x15, 0xe4, 0xda, 0x96, 0xe9, 0x22, 0x3e, 0x0f, 0x37, 0x5d, 0xf4, 0x55,
	0x1d, 0x99, 0x1a, 0xc2, 0xce, 0x8f, 0x15, 0xe6, 0xdb, 0x2d, 0x31, 0x1d, 0xb8, 0x16, 0x44, 0x24,
	0x85, 0x82, 0xa4, 0x3f, 0x38, 0xc8, 0x9c, 0xb8, 0xe5, 0x53, 0xd3, 0x37, 0xee, 0xd4, 0x46, 0xe6,
	0xb1, 0xa9, 0x7b, 0xfc, 0x0e, 0x4c, 0x84, 0xf7, 0x8f, 0x6f, 0xb7, 0xc4, 0x59, 0xc2, 0x42, 0x37,
	0x6e, 0xdc, 0x26, 0x5b, 0x76, 0x1f, 0x20, 0xb2, 0x57, 0x8b, 0xed, 0x96, 0x98, 0x21, 0x78, 0x76,
	0x93, 0x26, 0x35, 0xba, 0x3d, 0x1f, 0xc3, 0x44, 0xf0, 0x03, 0xef, 0xd0, 0xd4, 0xde, 0x2a, 0x63,
	0x79, 0xd0, 0x8e, 0x8d, 0x5d, 0x39, 0xd8, 0x4f, 0xa5, 0x03, 0x66, 0x4c, 0x58, 0x81, 0xe5, 0x88,
	0xf2, 0x8e, 0x11, 0xd2, 0x8f, 0x23, 0x30, 0x17, 0x8a, 0x9e, 0x39, 0xcd, 0x77, 0xb8, 0x2c, 0x5e,
	0x81, 0x05, 0xcd, 0xaa, 0x9b, 0x1e, 0x72, 0x6c, 0xd5, 0xf1, 0x9a, 0x17, 0x0d, 0xe4, 0xb8, 0xba,
	0x65, 0xe2, 0x76, 0x9c, 0x2c, 0x88, 0xed, 0x96, 0xb8, 0x12, 0xe4, 0x8d, 0x41, 0x49, 0xca, 0x3c,
	0xbb, 0x7c, 0x4e, 0x56, 0x19, 0xab, 0x04, 0xc8, 0xf6, 0x9a, 0x41, 0x9d, 0xfa, 0xad, 0xd7, 0xa9,
	0x03, 0xad, 0x3a, 0x0c, 0xa7, 0x9e, 0xc0, 0x52, 0xa8, 0x16, 0x86, 0x62, 0x14, 0x53, 0x48, 0xed,
	0x96, 0x98, 0x8b, 0x29, 0x9a, 0xe5, 0x5b, 0x64, 0x23, 0xdd, 0x67, 0x7f, 0xb8, 0x6e, 0x1e, 0x68,
	0x55, 0xea, 0xe6, 0x77, 0x1c, 0x2c, 0x84, 0x82, 0x87, 0x96, 0xf9, 0xa5, 0xee, 0x18, 0x43, 0x70,
	0x94, 0x51, 0x98, 0x83, 0xd5, 0x38, 0x11, 0x54, 0xe5, 0x9f, 0x1c, 0x7e, 0x76, 0xbe, 0x70, 0x74,
	0x0f, 0x75, 0x1e, 0x9d, 0x53, 0xe7, 0xcc, 0xc1, 0x16, 0xbe, 0x1f, 0x4f, 0xff, 0x26, 0x6c, 0x24,
	0x56, 0x40, 0xeb, 0xfc, 0x7d, 0x04, 0xe6, 0x59, 0xd4, 0x81, 0x56, 0x1d, 0x56, 0x85, 0xef, 0x6f,
	0x7b, 0xaf, 0xc1, 0x4a, 0x8c, 0x67, 0xd4, 0xd3, 0xef, 0x39, 0x58, 0x62, 0xe3, 0x41, 0x6f, 0x0d,
	0xc9, 0x57, 0x46, 0xe7, 0x06, 0x88, 0x09, 0x3a, 0xa8, 0x56, 0x1b, 0xd2, 0xf8, 0x39, 0x50, 0x90,
	0xd6, 0x08, 0x26, 0x94, 0x4f, 0x61, 0xdc, 0xc6, 0x57, 0x58, 0xe1, 0xd4, 0xde, 0x4a, 0x6c, 0xe3,
	0x11, 0x70, 0x61, 0xcc, 0x3f, 0xea, 0x95, 0xe0, 0x06, 0x3e, 0x0b, 0x13, 0x0e, 0xaa, 0xa9, 0x4d,
	0xe4, 0x10, 0xb5, 0x4a, 0xe7, 0x27, 0x23, 0x6a, 0x19, 0x9b, 0xc3, 0x66, 0xa4, 0x62, 0x5c, 0xe0,
	0x71, 0xe8, 0x8c, 0x9c, 0xeb, 0xc3, 0xd1, 0xb3, 0x0a, 0x42, 0x34, 0x29, 0x95, 0xf4, 0x0b, 0x17,
	0x84, 0x0f, 0xb4, 0xaa, 0x69, 0x7d, 0x5d, 0x43, 0xa5, 0x32, 0xf2, 0xe7, 0xbb, 0xb7, 0xd7, 0xb6,
	0x0d, 0x69, 0x35, 0xcc, 0x89, 0x35, 0x4e, 0x2b, 0xbd, 0xcb, 0x6c, 0x15, 0xa3, 0x49, 0x55, 0x6c,
	0x81, 0x94, 0x2c, 0x93, 0x56, 0xf3, 0x2b, 0x99, 0x65, 0x70, 0x47, 0x90, 0x90, 0x7f, 0x94, 0xbd,
	0x45, 0x11, 0x9f, 0xc7, 0x17, 0x31, 0xb5, 0xb7, 0x15, 0xcb, 0xd1, 0xa3, 0x2e, 0x52, 0x6a, 0x64,
	0x76, 0x09, 0x2b, 0xa5, 0x75, 0x3c, 0xc5, 0xd3, 0xdd, 0x43, 0x43, 0xf7, 0x57, 0x49, 0xf8, 0x61,
	0xc3, 0xb7, 0xea, 0xbf, 0x97, 0xc2, 0xa4, 0x16, 0x61, 0x2d, 0x96, 0x9d, 0xa6, 0x7f, 0x86, 0xb5,
	0xf9, 0x80, 0x50, 0xd3, 0xfc, 0x8f, 0x12, 0xc8, 0xbb, 0x3b, 0x3e, 0x43, 0x47, 0xc6, 0xde, 0xeb,
	0x1b, 0x90, 0x3e, 0xd7, 0x1d, 0xaf, 0xae, 0xd6, 0x8e, 0x0b, 0x87, 0x87, 0x15, 0x55, 0x37, 0xf9,
	0x22, 0xcc, 0xf6, 0x4c, 0xaa, 0x9b, 0x72, 0xef, 0x3f, 0x46, 0x72, 0x64, 0x28, 0x14, 0x76, 0x06,
	0x00, 0xd1, 0x11, 0xfa, 0x02, 0x66, 0xc2, 0x53, 0xa3, 0xd4, 0xe7, 0xee, 0x33, 0xa7, 0x29, 0x7c,
	0xd4, 0x1f, 0x13, 0x9f, 0xc0, 0xef, 0xd0, 0x7e, 0x09, 0x0e, 0xb4, 0x6a, 0xdf, 0x04, 0x4c, 0xff,
	0xf0, 0x55, 0xc8, 0x44, 0xe7, 0x8f, 0x0f, 0xfb, 0x10, 0x04, 0x38, 0x41, 0x1e, 0x0c, 0x47, 0x93,
	0x3d, 0x85, 0xe9, 0xd0, 0xfb, 0x75, 0x23, 0xe1, 0xfe, 0x2e, 0x44, 0xb8, 0xd3, 0x17, 0x42, 0xd9,
	0xbf, 0x85, 0xa5, 0xa4, 0x97, 0xd3, 0xdd, 0x04, 0x96, 0x58, 0xb4, 0x70, 0xff, 0x4d, 0xd0, 0x34,
	0x3d, 0x82, 0x74, 0xef, 0xfb, 0x7a, 0x2b, 0x81, 0x28, 0x84, 0x12, 0xee, 0x0e, 0x82, 0xa2, 0xad,
	0xfe, 0xf3, 0x38, 0x64, 0xba, 0xad, 0xfe, 0x58, 0x2f, 0x21, 0x4d, 0x75, 0xf8, 0xe7, 0x70, 0x2b,
	0x69, 0x40, 0x8b, 0x65, 0x8f, 0x07, 0x0b, 0xfb, 0x6f, 0x00, 0xa6, 0x85, 0x57, 0x60, 0x2e, 0x32,
	0x34, 0x7d, 0x70, 0x3d, 0x51, 0x00, 0x13, 0xee, 0x0d, 0x04, 0xa3, 0x99, 0x3c, 0x58, 0x88, 0x1d,
	0x25, 0xee, 0x5c, 0x4f, 0xc3, 0x40, 0x85, 0xdd, 0x81, 0xa1, 0x34, 0xeb, 0x39, 0x00, 0xf3, 0xd5,
	0x42, 0x8c, 0x25, 0xe8, 0x02, 0x84, 0xdb, 0x7d, 0x00, 0x94, 0xb7, 0x08, 0xb3, 0x3d, 0xc7, 0xcf,
	0x66, 0xb2, 0x38, 0x0a, 0x12, 0x76, 0x06, 0x00, 0xd1, 0x1c, 0x26, 0xf0, 0x31, 0x67, 0x43, 0xbc,
	0xc4, 0x28, 0x50, 0xc8, 0x0f, 0x08, 0xa4, 0xf9, 0x9e, 0xc3, 0xad, 0x84, 0xc3, 0x60, 0x27, 0x91,
	0x2a, 0x0a, 0x4e, 0xe8, 0xc3, 0xeb, 0x0f, 0x81, 0xc2, 0xc9, 0xcb, 0xcb, 0x1c, 0xf7, 0xea, 0x32,
	0xc7, 0xfd, 0x7d, 0x99, 0xe3, 0x7e, 0xba, 0xca, 0xa5, 0x5e, 0x5d, 0xe5, 0x52, 0x7f, 0x5d, 0xe5,
	0x52, 0x4f, 0xf6, 0xcb, 0xba, 0x57, 0xa9, 0x17, 0x65, 0xcd, 0x32, 0xf2, 0x9a, 0xe5, 0x1a, 0x96,
	0x9b, 0xd7, 0x8b, 0xda, 0xbd, 0xb2, 0x95, 0x6f, 0x7c, 0x92, 0x37, 0xac, 0x52, 0xbd, 0x86, 0x5c,
	0xe6, 0x5b, 0x9a, 0xd7, 0xb4, 0x91, 0x5b, 0x1c, 0xc7, 0xdf, 0xad, 0xf6, 0xff, 0x0d, 0x00, 0x00,
	0xff, 0xff, 0x4b, 0xea, 0x0a, 0xeb, 0x69, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VirtualIBCChainClient is the client API for VirtualIBCChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VirtualIBCChainClient interface {
	// OnChanOpenInit defines a rpc handler method for MsgOnChanOpenInit.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<INIT>
	OnChanOpenInit(ctx context.Context, in *MsgOnChanOpenInit, opts ...grpc.CallOption) (*MsgOnChanOpenInitResponse, error)
	// OnChanOpenTry defines a rpc handler method for MsgOnChanOpenTry.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<TRYOPEN>
	OnChanOpenTry(ctx context.Context, in *MsgOnChanOpenTry, opts ...grpc.CallOption) (*MsgOnChanOpenTryResponse, error)
	// OnChanOpenAck defines a rpc handler method for MsgOnChanOpenAck.
	// Proofs:
	// - exists: channel<INIT>
	// - non-exists: channel<OPEN>
	OnChanOpenAck(ctx context.Context, in *MsgOnChanOpenAck, opts ...grpc.CallOption) (*MsgOnChanOpenAckResponse, error)
	// OnChanOpenConfirm defines a rpc handler method for MsgOnChanOpenConfirm.
	// Proofs:
	// - exists: channel<TRYOPEN>
	// - non-exists: channel<OPEN>
	OnChanOpenConfirm(ctx context.Context, in *MsgOnChanOpenConfirm, opts ...grpc.CallOption) (*MsgOnChanOpenConfirmResponse, error)
	// OnRecvPacket defines a rpc handler method for MsgOnRecvPacket.
	// Proofs:
	// - exists: packet commitment
	// - exists: packet receipt OR packet recv sequence
	OnRecvPacket(ctx context.Context, in *MsgOnRecvPacket, opts ...grpc.CallOption) (*MsgOnRecvPacketResponse, error)
	// OnAcknowledgementPacket defines a rpc handler method for MsgOnAcknowledgementPacket.
	OnAcknowledgementPacket(ctx context.Context, in *MsgOnAcknowledgementPacket, opts ...grpc.CallOption) (*MsgOnAcknowledgementPacketResponse, error)
	// OnTimeoutPacket defines a rpc handler method for MsgOnTimeoutPacket.
	OnTimeoutPacket(ctx context.Context, in *MsgOnTimeoutPacket, opts ...grpc.CallOption) (*MsgOnTimeoutPacketResponse, error)
}

type virtualIBCChainClient struct {
	cc grpc1.ClientConn
}

func NewVirtualIBCChainClient(cc grpc1.ClientConn) VirtualIBCChainClient {
	return &virtualIBCChainClient{cc}
}

func (c *virtualIBCChainClient) OnChanOpenInit(ctx context.Context, in *MsgOnChanOpenInit, opts ...grpc.CallOption) (*MsgOnChanOpenInitResponse, error) {
	out := new(MsgOnChanOpenInitResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenTry(ctx context.Context, in *MsgOnChanOpenTry, opts ...grpc.CallOption) (*MsgOnChanOpenTryResponse, error) {
	out := new(MsgOnChanOpenTryResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenTry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenAck(ctx context.Context, in *MsgOnChanOpenAck, opts ...grpc.CallOption) (*MsgOnChanOpenAckResponse, error) {
	out := new(MsgOnChanOpenAckResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenConfirm(ctx context.Context, in *MsgOnChanOpenConfirm, opts ...grpc.CallOption) (*MsgOnChanOpenConfirmResponse, error) {
	out := new(MsgOnChanOpenConfirmResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenConfirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnRecvPacket(ctx context.Context, in *MsgOnRecvPacket, opts ...grpc.CallOption) (*MsgOnRecvPacketResponse, error) {
	out := new(MsgOnRecvPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnRecvPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnAcknowledgementPacket(ctx context.Context, in *MsgOnAcknowledgementPacket, opts ...grpc.CallOption) (*MsgOnAcknowledgementPacketResponse, error) {
	out := new(MsgOnAcknowledgementPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnAcknowledgementPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnTimeoutPacket(ctx context.Context, in *MsgOnTimeoutPacket, opts ...grpc.CallOption) (*MsgOnTimeoutPacketResponse, error) {
	out := new(MsgOnTimeoutPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnTimeoutPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualIBCChainServer is the server API for VirtualIBCChain service.
type VirtualIBCChainServer interface {
	// OnChanOpenInit defines a rpc handler method for MsgOnChanOpenInit.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<INIT>
	OnChanOpenInit(context.Context, *MsgOnChanOpenInit) (*MsgOnChanOpenInitResponse, error)
	// OnChanOpenTry defines a rpc handler method for MsgOnChanOpenTry.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<TRYOPEN>
	OnChanOpenTry(context.Context, *MsgOnChanOpenTry) (*MsgOnChanOpenTryResponse, error)
	// OnChanOpenAck defines a rpc handler method for MsgOnChanOpenAck.
	// Proofs:
	// - exists: channel<INIT>
	// - non-exists: channel<OPEN>
	OnChanOpenAck(context.Context, *MsgOnChanOpenAck) (*MsgOnChanOpenAckResponse, error)
	// OnChanOpenConfirm defines a rpc handler method for MsgOnChanOpenConfirm.
	// Proofs:
	// - exists: channel<TRYOPEN>
	// - non-exists: channel<OPEN>
	OnChanOpenConfirm(context.Context, *MsgOnChanOpenConfirm) (*MsgOnChanOpenConfirmResponse, error)
	// OnRecvPacket defines a rpc handler method for MsgOnRecvPacket.
	// Proofs:
	// - exists: packet commitment
	// - exists: packet receipt OR packet recv sequence
	OnRecvPacket(context.Context, *MsgOnRecvPacket) (*MsgOnRecvPacketResponse, error)
	// OnAcknowledgementPacket defines a rpc handler method for MsgOnAcknowledgementPacket.
	OnAcknowledgementPacket(context.Context, *MsgOnAcknowledgementPacket) (*MsgOnAcknowledgementPacketResponse, error)
	// OnTimeoutPacket defines a rpc handler method for MsgOnTimeoutPacket.
	OnTimeoutPacket(context.Context, *MsgOnTimeoutPacket) (*MsgOnTimeoutPacketResponse, error)
}

// UnimplementedVirtualIBCChainServer can be embedded to have forward compatible implementations.
type UnimplementedVirtualIBCChainServer struct {
}

func (*UnimplementedVirtualIBCChainServer) OnChanOpenInit(ctx context.Context, req *MsgOnChanOpenInit) (*MsgOnChanOpenInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenInit not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenTry(ctx context.Context, req *MsgOnChanOpenTry) (*MsgOnChanOpenTryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenTry not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenAck(ctx context.Context, req *MsgOnChanOpenAck) (*MsgOnChanOpenAckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenAck not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenConfirm(ctx context.Context, req *MsgOnChanOpenConfirm) (*MsgOnChanOpenConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenConfirm not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnRecvPacket(ctx context.Context, req *MsgOnRecvPacket) (*MsgOnRecvPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnRecvPacket not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnAcknowledgementPacket(ctx context.Context, req *MsgOnAcknowledgementPacket) (*MsgOnAcknowledgementPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnAcknowledgementPacket not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnTimeoutPacket(ctx context.Context, req *MsgOnTimeoutPacket) (*MsgOnTimeoutPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnTimeoutPacket not implemented")
}

func RegisterVirtualIBCChainServer(s grpc1.Server, srv VirtualIBCChainServer) {
	s.RegisterService(&_VirtualIBCChain_serviceDesc, srv)
}

func _VirtualIBCChain_OnChanOpenInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenInit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenInit(ctx, req.(*MsgOnChanOpenInit))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenTry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenTry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenTry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenTry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenTry(ctx, req.(*MsgOnChanOpenTry))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenAck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenAck(ctx, req.(*MsgOnChanOpenAck))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenConfirm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenConfirm(ctx, req.(*MsgOnChanOpenConfirm))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnRecvPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnRecvPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnRecvPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnRecvPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnRecvPacket(ctx, req.(*MsgOnRecvPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnAcknowledgementPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnAcknowledgementPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnAcknowledgementPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnAcknowledgementPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnAcknowledgementPacket(ctx, req.(*MsgOnAcknowledgementPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnTimeoutPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnTimeoutPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnTimeoutPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnTimeoutPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnTimeoutPacket(ctx, req.(*MsgOnTimeoutPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualIBCChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.core.vibc.v1.VirtualIBCChain",
	HandlerType: (*VirtualIBCChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnChanOpenInit",
			Handler:    _VirtualIBCChain_OnChanOpenInit_Handler,
		},
		{
			MethodName: "OnChanOpenTry",
			Handler:    _VirtualIBCChain_OnChanOpenTry_Handler,
		},
		{
			MethodName: "OnChanOpenAck",
			Handler:    _VirtualIBCChain_OnChanOpenAck_Handler,
		},
		{
			MethodName: "OnChanOpenConfirm",
			Handler:    _VirtualIBCChain_OnChanOpenConfirm_Handler,
		},
		{
			MethodName: "OnRecvPacket",
			Handler:    _VirtualIBCChain_OnRecvPacket_Handler,
		},
		{
			MethodName: "OnAcknowledgementPacket",
			Handler:    _VirtualIBCChain_OnAcknowledgementPacket_Handler,
		},
		{
			MethodName: "OnTimeoutPacket",
			Handler:    _VirtualIBCChain_OnTimeoutPacket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/core/vibc/v1/tx.proto",
}

// VirtualIBCSidecarClient is the client API for VirtualIBCSidecar service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VirtualIBCSidecarClient interface {
	// WriteOpenInitOrTryChan defines a rpc handler method for MsgWriteOpenInitOrTryChan.
	WriteOpenInitOrTryChan(ctx context.Context, in *MsgWriteOpenInitOrTryChan, opts ...grpc.CallOption) (*MsgWriteOpenInitOrTryChanResponse, error)
	// WriteOpenAckChan defines a rpc handler method for MsgWriteOpenAckChan.
	WriteOpenAckChan(ctx context.Context, in *MsgWriteOpenAckChan, opts ...grpc.CallOption) (*MsgWriteOpenAckChanResponse, error)
	// WriteOpenConfirmChan defines a rpc handler method for MsgWriteOpenConfirmChan.
	WriteOpenConfirmChan(ctx context.Context, in *MsgWriteOpenConfirmChan, opts ...grpc.CallOption) (*MsgWriteOpenConfirmChanResponse, error)
	// The chain is also active in the initiation of the packet lifecycle.
	// SendPacket defines a rpc handler method for MsgSendPacket.
	SendPacket(ctx context.Context, in *MsgSendPacket, opts ...grpc.CallOption) (*MsgSendPacketResponse, error)
	// WritePacketAck defines a rpc handler method for MsgWritePacketAck.
	// This completes the RecvPacket flow.
	WritePacketAck(ctx context.Context, in *MsgWritePacketAck, opts ...grpc.CallOption) (*MsgWritePacketAckResponse, error)
	// EmitAckPacketEvent defines a rpc handler method for MsgEmitAckPacketEvent.
	// This completes the Acknowledgement flow.
	EmitAckPacketEvent(ctx context.Context, in *MsgEmitAckPacketEvent, opts ...grpc.CallOption) (*MsgEmitAckPacketEventResponse, error)
	// EmitTimeoutPacketEvent defines a rpc handler method for MsgEmitTimeoutPacketEvent.
	// This completes the Acknowledgement flow.
	EmitTimeoutPacketEvent(ctx context.Context, in *MsgEmitTimeoutPacketEvent, opts ...grpc.CallOption) (*MsgEmitTimeoutPacketEventResponse, error)
}

type virtualIBCSidecarClient struct {
	cc grpc1.ClientConn
}

func NewVirtualIBCSidecarClient(cc grpc1.ClientConn) VirtualIBCSidecarClient {
	return &virtualIBCSidecarClient{cc}
}

func (c *virtualIBCSidecarClient) WriteOpenInitOrTryChan(ctx context.Context, in *MsgWriteOpenInitOrTryChan, opts ...grpc.CallOption) (*MsgWriteOpenInitOrTryChanResponse, error) {
	out := new(MsgWriteOpenInitOrTryChanResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/WriteOpenInitOrTryChan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) WriteOpenAckChan(ctx context.Context, in *MsgWriteOpenAckChan, opts ...grpc.CallOption) (*MsgWriteOpenAckChanResponse, error) {
	out := new(MsgWriteOpenAckChanResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/WriteOpenAckChan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) WriteOpenConfirmChan(ctx context.Context, in *MsgWriteOpenConfirmChan, opts ...grpc.CallOption) (*MsgWriteOpenConfirmChanResponse, error) {
	out := new(MsgWriteOpenConfirmChanResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/WriteOpenConfirmChan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) SendPacket(ctx context.Context, in *MsgSendPacket, opts ...grpc.CallOption) (*MsgSendPacketResponse, error) {
	out := new(MsgSendPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/SendPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) WritePacketAck(ctx context.Context, in *MsgWritePacketAck, opts ...grpc.CallOption) (*MsgWritePacketAckResponse, error) {
	out := new(MsgWritePacketAckResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/WritePacketAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) EmitAckPacketEvent(ctx context.Context, in *MsgEmitAckPacketEvent, opts ...grpc.CallOption) (*MsgEmitAckPacketEventResponse, error) {
	out := new(MsgEmitAckPacketEventResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/EmitAckPacketEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) EmitTimeoutPacketEvent(ctx context.Context, in *MsgEmitTimeoutPacketEvent, opts ...grpc.CallOption) (*MsgEmitTimeoutPacketEventResponse, error) {
	out := new(MsgEmitTimeoutPacketEventResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/EmitTimeoutPacketEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualIBCSidecarServer is the server API for VirtualIBCSidecar service.
type VirtualIBCSidecarServer interface {
	// WriteOpenInitOrTryChan defines a rpc handler method for MsgWriteOpenInitOrTryChan.
	WriteOpenInitOrTryChan(context.Context, *MsgWriteOpenInitOrTryChan) (*MsgWriteOpenInitOrTryChanResponse, error)
	// WriteOpenAckChan defines a rpc handler method for MsgWriteOpenAckChan.
	WriteOpenAckChan(context.Context, *MsgWriteOpenAckChan) (*MsgWriteOpenAckChanResponse, error)
	// WriteOpenConfirmChan defines a rpc handler method for MsgWriteOpenConfirmChan.
	WriteOpenConfirmChan(context.Context, *MsgWriteOpenConfirmChan) (*MsgWriteOpenConfirmChanResponse, error)
	// The chain is also active in the initiation of the packet lifecycle.
	// SendPacket defines a rpc handler method for MsgSendPacket.
	SendPacket(context.Context, *MsgSendPacket) (*MsgSendPacketResponse, error)
	// WritePacketAck defines a rpc handler method for MsgWritePacketAck.
	// This completes the RecvPacket flow.
	WritePacketAck(context.Context, *MsgWritePacketAck) (*MsgWritePacketAckResponse, error)
	// EmitAckPacketEvent defines a rpc handler method for MsgEmitAckPacketEvent.
	// This completes the Acknowledgement flow.
	EmitAckPacketEvent(context.Context, *MsgEmitAckPacketEvent) (*MsgEmitAckPacketEventResponse, error)
	// EmitTimeoutPacketEvent defines a rpc handler method for MsgEmitTimeoutPacketEvent.
	// This completes the Acknowledgement flow.
	EmitTimeoutPacketEvent(context.Context, *MsgEmitTimeoutPacketEvent) (*MsgEmitTimeoutPacketEventResponse, error)
}

// UnimplementedVirtualIBCSidecarServer can be embedded to have forward compatible implementations.
type UnimplementedVirtualIBCSidecarServer struct {
}

func (*UnimplementedVirtualIBCSidecarServer) WriteOpenInitOrTryChan(ctx context.Context, req *MsgWriteOpenInitOrTryChan) (*MsgWriteOpenInitOrTryChanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteOpenInitOrTryChan not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) WriteOpenAckChan(ctx context.Context, req *MsgWriteOpenAckChan) (*MsgWriteOpenAckChanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteOpenAckChan not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) WriteOpenConfirmChan(ctx context.Context, req *MsgWriteOpenConfirmChan) (*MsgWriteOpenConfirmChanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WriteOpenConfirmChan not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) SendPacket(ctx context.Context, req *MsgSendPacket) (*MsgSendPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPacket not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) WritePacketAck(ctx context.Context, req *MsgWritePacketAck) (*MsgWritePacketAckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WritePacketAck not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) EmitAckPacketEvent(ctx context.Context, req *MsgEmitAckPacketEvent) (*MsgEmitAckPacketEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmitAckPacketEvent not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) EmitTimeoutPacketEvent(ctx context.Context, req *MsgEmitTimeoutPacketEvent) (*MsgEmitTimeoutPacketEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EmitTimeoutPacketEvent not implemented")
}

func RegisterVirtualIBCSidecarServer(s grpc1.Server, srv VirtualIBCSidecarServer) {
	s.RegisterService(&_VirtualIBCSidecar_serviceDesc, srv)
}

func _VirtualIBCSidecar_WriteOpenInitOrTryChan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWriteOpenInitOrTryChan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).WriteOpenInitOrTryChan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/WriteOpenInitOrTryChan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).WriteOpenInitOrTryChan(ctx, req.(*MsgWriteOpenInitOrTryChan))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_WriteOpenAckChan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWriteOpenAckChan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).WriteOpenAckChan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/WriteOpenAckChan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).WriteOpenAckChan(ctx, req.(*MsgWriteOpenAckChan))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_WriteOpenConfirmChan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWriteOpenConfirmChan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).WriteOpenConfirmChan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/WriteOpenConfirmChan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).WriteOpenConfirmChan(ctx, req.(*MsgWriteOpenConfirmChan))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_SendPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).SendPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/SendPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).SendPacket(ctx, req.(*MsgSendPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_WritePacketAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgWritePacketAck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).WritePacketAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/WritePacketAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).WritePacketAck(ctx, req.(*MsgWritePacketAck))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_EmitAckPacketEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEmitAckPacketEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).EmitAckPacketEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/EmitAckPacketEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).EmitAckPacketEvent(ctx, req.(*MsgEmitAckPacketEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_EmitTimeoutPacketEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEmitTimeoutPacketEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).EmitTimeoutPacketEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/EmitTimeoutPacketEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).EmitTimeoutPacketEvent(ctx, req.(*MsgEmitTimeoutPacketEvent))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualIBCSidecar_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.core.vibc.v1.VirtualIBCSidecar",
	HandlerType: (*VirtualIBCSidecarServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WriteOpenInitOrTryChan",
			Handler:    _VirtualIBCSidecar_WriteOpenInitOrTryChan_Handler,
		},
		{
			MethodName: "WriteOpenAckChan",
			Handler:    _VirtualIBCSidecar_WriteOpenAckChan_Handler,
		},
		{
			MethodName: "WriteOpenConfirmChan",
			Handler:    _VirtualIBCSidecar_WriteOpenConfirmChan_Handler,
		},
		{
			MethodName: "SendPacket",
			Handler:    _VirtualIBCSidecar_SendPacket_Handler,
		},
		{
			MethodName: "WritePacketAck",
			Handler:    _VirtualIBCSidecar_WritePacketAck_Handler,
		},
		{
			MethodName: "EmitAckPacketEvent",
			Handler:    _VirtualIBCSidecar_EmitAckPacketEvent_Handler,
		},
		{
			MethodName: "EmitTimeoutPacketEvent",
			Handler:    _VirtualIBCSidecar_EmitTimeoutPacketEvent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/core/vibc/v1/tx.proto",
}

func (m *MsgSendPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TimeoutTimestamp != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TimeoutTimestamp))
		i--
		dAtA[i] = 0x28
	}
	{
		size, err := m.TimeoutHeight.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SourceChannelId) > 0 {
		i -= len(m.SourceChannelId)
		copy(dAtA[i:], m.SourceChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourcePortId) > 0 {
		i -= len(m.SourcePortId)
		copy(dAtA[i:], m.SourcePortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourcePortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenTry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenTry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenTry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenTryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenTryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenTryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CounterpartyChannelId) > 0 {
		i -= len(m.CounterpartyChannelId)
		copy(dAtA[i:], m.CounterpartyChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenAckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenAckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenAckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenConfirmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenConfirmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenConfirmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWriteOpenInitOrTryChan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWriteOpenInitOrTryChan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWriteOpenInitOrTryChan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		{
			size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWriteOpenInitOrTryChanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWriteOpenInitOrTryChanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWriteOpenInitOrTryChanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWriteOpenAckChan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWriteOpenAckChan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWriteOpenAckChan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CounterpartyChannelId) > 0 {
		i -= len(m.CounterpartyChannelId)
		copy(dAtA[i:], m.CounterpartyChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWriteOpenAckChanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWriteOpenAckChanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWriteOpenAckChanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWriteOpenConfirmChan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWriteOpenConfirmChan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWriteOpenConfirmChan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWriteOpenConfirmChanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWriteOpenConfirmChanResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWriteOpenConfirmChanResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnRecvPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnRecvPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnRecvPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnRecvPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnRecvPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnRecvPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnTimeoutPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnTimeoutPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnTimeoutPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnTimeoutPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnTimeoutPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnTimeoutPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgOnAcknowledgementPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnAcknowledgementPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnAcknowledgementPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Acknowledgement) > 0 {
		i -= len(m.Acknowledgement)
		copy(dAtA[i:], m.Acknowledgement)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Acknowledgement)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnAcknowledgementPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnAcknowledgementPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnAcknowledgementPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgWritePacketAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWritePacketAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWritePacketAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Acknowledgement != nil {
		{
			size, err := m.Acknowledgement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgWritePacketAckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWritePacketAckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWritePacketAckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgEmitAckPacketEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmitAckPacketEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmitAckPacketEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgEmitAckPacketEventResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmitAckPacketEventResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmitAckPacketEventResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgEmitTimeoutPacketEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmitTimeoutPacketEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmitTimeoutPacketEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgEmitTimeoutPacketEventResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEmitTimeoutPacketEventResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEmitTimeoutPacketEventResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgSendPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourcePortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.TimeoutHeight.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.TimeoutTimestamp != 0 {
		n += 1 + sovTx(uint64(m.TimeoutTimestamp))
	}
	return n
}

func (m *MsgSendPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sequence != 0 {
		n += 1 + sovTx(uint64(m.Sequence))
	}
	return n
}

func (m *MsgOnChanOpenInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnChanOpenTry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenTryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnChanOpenAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenAckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnChanOpenConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenConfirmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWriteOpenInitOrTryChan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWriteOpenInitOrTryChanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWriteOpenAckChan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWriteOpenAckChanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWriteOpenConfirmChan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWriteOpenConfirmChanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnRecvPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnRecvPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnTimeoutPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnTimeoutPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgOnAcknowledgementPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Acknowledgement)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnAcknowledgementPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgWritePacketAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	if m.Acknowledgement != nil {
		l = m.Acknowledgement.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgWritePacketAckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgEmitAckPacketEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgEmitAckPacketEventResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgEmitTimeoutPacketEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgEmitTimeoutPacketEventResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgSendPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutHeight", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TimeoutHeight.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTimestamp", wireType)
			}
			m.TimeoutTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &types1.Channel{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenTry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenTry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenTry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &types1.Channel{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenTryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenTryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenTryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenAckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenAckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenAckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenConfirmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWriteOpenInitOrTryChan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWriteOpenInitOrTryChan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWriteOpenInitOrTryChan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &types1.Channel{}
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWriteOpenInitOrTryChanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWriteOpenInitOrTryChanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWriteOpenInitOrTryChanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWriteOpenAckChan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWriteOpenAckChan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWriteOpenAckChan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWriteOpenAckChanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWriteOpenAckChanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWriteOpenAckChanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWriteOpenConfirmChan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWriteOpenConfirmChan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWriteOpenConfirmChan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWriteOpenConfirmChanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWriteOpenConfirmChanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWriteOpenConfirmChanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnRecvPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnRecvPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnRecvPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnRecvPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnRecvPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnRecvPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnTimeoutPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnTimeoutPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnTimeoutPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnTimeoutPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnTimeoutPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnTimeoutPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnAcknowledgementPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledgement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acknowledgement = append(m.Acknowledgement[:0], dAtA[iNdEx:postIndex]...)
			if m.Acknowledgement == nil {
				m.Acknowledgement = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnAcknowledgementPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWritePacketAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWritePacketAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWritePacketAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledgement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledgement == nil {
				m.Acknowledgement = &types1.Acknowledgement{}
			}
			if err := m.Acknowledgement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWritePacketAckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWritePacketAckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWritePacketAckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmitAckPacketEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmitAckPacketEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmitAckPacketEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmitAckPacketEventResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmitAckPacketEventResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmitAckPacketEventResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmitTimeoutPacketEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmitTimeoutPacketEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmitTimeoutPacketEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEmitTimeoutPacketEventResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEmitTimeoutPacketEventResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEmitTimeoutPacketEventResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
