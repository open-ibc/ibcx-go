// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ibc/core/vibc/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/ibc-go/v7/modules/core/02-client/types"
	types "github.com/cosmos/ibc-go/v7/modules/core/04-channel/types"
	_ "github.com/cosmos/ibc-go/v7/modules/core/23-commitment/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ResponseResultType defines the possible outcomes of the execution of a message
type ResponseResultType int32

const (
	// Default zero value enumeration
	UNSPECIFIED ResponseResultType = 0
	// The message did not call the IBC application callbacks (because, for example, the packet had already been relayed)
	NOOP ResponseResultType = 1
	// The message was executed successfully
	SUCCESS ResponseResultType = 2
	// The message was executed with an error
	ERROR ResponseResultType = 3
)

var ResponseResultType_name = map[int32]string{
	0: "RESPONSE_RESULT_TYPE_UNSPECIFIED",
	1: "RESPONSE_RESULT_TYPE_NOOP",
	2: "RESPONSE_RESULT_TYPE_SUCCESS",
	3: "RESPONSE_RESULT_TYPE_ERROR",
}

var ResponseResultType_value = map[string]int32{
	"RESPONSE_RESULT_TYPE_UNSPECIFIED": 0,
	"RESPONSE_RESULT_TYPE_NOOP":        1,
	"RESPONSE_RESULT_TYPE_SUCCESS":     2,
	"RESPONSE_RESULT_TYPE_ERROR":       3,
}

func (x ResponseResultType) String() string {
	return proto.EnumName(ResponseResultType_name, int32(x))
}

func (ResponseResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{0}
}

// MsgSendPacket defines an sdk.Msg to send a packet.
// It is initiated by the vIBC chain side.
type MsgSendPacket struct {
	SourcePortId    string        `protobuf:"bytes,1,opt,name=source_port_id,json=sourcePortId,proto3" json:"source_port_id,omitempty" yaml:"source_port_id"`
	SourceChannelId string        `protobuf:"bytes,2,opt,name=source_channel_id,json=sourceChannelId,proto3" json:"source_channel_id,omitempty" yaml:"source_channel_id"`
	Channel         types.Channel `protobuf:"bytes,3,opt,name=channel,proto3" json:"channel"`
}

func (m *MsgSendPacket) Reset()         { *m = MsgSendPacket{} }
func (m *MsgSendPacket) String() string { return proto.CompactTextString(m) }
func (*MsgSendPacket) ProtoMessage()    {}
func (*MsgSendPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{0}
}
func (m *MsgSendPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendPacket.Merge(m, src)
}
func (m *MsgSendPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendPacket proto.InternalMessageInfo

// MsgSendPacketResponse defines an sdk.Msg for a send packet response.
// It is returned by the vIBC sidecar side.
type MsgSendPacketResponse struct {
	Result   ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
	Sequence uint64             `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence,omitempty" yaml:"sequence"`
}

func (m *MsgSendPacketResponse) Reset()         { *m = MsgSendPacketResponse{} }
func (m *MsgSendPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSendPacketResponse) ProtoMessage()    {}
func (*MsgSendPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{1}
}
func (m *MsgSendPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSendPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSendPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSendPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSendPacketResponse.Merge(m, src)
}
func (m *MsgSendPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSendPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSendPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSendPacketResponse proto.InternalMessageInfo

// MsgChannelOpenInit defines an sdk.Msg to initialize a channel handshake.
// It originates from the vIBC chain side.
type MsgChannelOpenInit struct {
	PortId  string        `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	Channel types.Channel `protobuf:"bytes,2,opt,name=channel,proto3" json:"channel"`
}

func (m *MsgChannelOpenInit) Reset()         { *m = MsgChannelOpenInit{} }
func (m *MsgChannelOpenInit) String() string { return proto.CompactTextString(m) }
func (*MsgChannelOpenInit) ProtoMessage()    {}
func (*MsgChannelOpenInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{2}
}
func (m *MsgChannelOpenInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgChannelOpenInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgChannelOpenInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgChannelOpenInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgChannelOpenInit.Merge(m, src)
}
func (m *MsgChannelOpenInit) XXX_Size() int {
	return m.Size()
}
func (m *MsgChannelOpenInit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgChannelOpenInit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgChannelOpenInit proto.InternalMessageInfo

// MsgChannelOpenInitResponse defines the Msg/ChannelOpenInit response type.
type MsgChannelOpenInitResponse struct {
	ChannelId string `protobuf:"bytes,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	Version   string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *MsgChannelOpenInitResponse) Reset()         { *m = MsgChannelOpenInitResponse{} }
func (m *MsgChannelOpenInitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgChannelOpenInitResponse) ProtoMessage()    {}
func (*MsgChannelOpenInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{3}
}
func (m *MsgChannelOpenInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgChannelOpenInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgChannelOpenInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgChannelOpenInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgChannelOpenInitResponse.Merge(m, src)
}
func (m *MsgChannelOpenInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgChannelOpenInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgChannelOpenInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgChannelOpenInitResponse proto.InternalMessageInfo

func (m *MsgChannelOpenInitResponse) GetChannelId() string {
	if m != nil {
		return m.ChannelId
	}
	return ""
}

func (m *MsgChannelOpenInitResponse) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// MsgOnChanOpenInit defines an sdk.Msg to for a channel init callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenInit struct {
	ConnectionHops []string           `protobuf:"bytes,1,rep,name=connection_hops,json=connectionHops,proto3" json:"connection_hops,omitempty" yaml:"connection_hops"`
	Ordering       types.Order        `protobuf:"varint,2,opt,name=ordering,proto3,enum=ibc.core.channel.v1.Order" json:"ordering,omitempty"`
	Party          types.Counterparty `protobuf:"bytes,3,opt,name=party,proto3" json:"party"`
	Counterparty   types.Counterparty `protobuf:"bytes,4,opt,name=counterparty,proto3" json:"counterparty"`
	PartyVersion   string             `protobuf:"bytes,5,opt,name=party_version,json=partyVersion,proto3" json:"party_version,omitempty" yaml:"party_version"`
}

func (m *MsgOnChanOpenInit) Reset()         { *m = MsgOnChanOpenInit{} }
func (m *MsgOnChanOpenInit) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenInit) ProtoMessage()    {}
func (*MsgOnChanOpenInit) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{4}
}
func (m *MsgOnChanOpenInit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenInit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenInit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenInit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenInit.Merge(m, src)
}
func (m *MsgOnChanOpenInit) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenInit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenInit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenInit proto.InternalMessageInfo

// MsgOnChanOpenInitResponse defines the Msg/OnChanOpenInit response type.
type MsgOnChanOpenInitResponse struct {
	Result  ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
	Version string             `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *MsgOnChanOpenInitResponse) Reset()         { *m = MsgOnChanOpenInitResponse{} }
func (m *MsgOnChanOpenInitResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenInitResponse) ProtoMessage()    {}
func (*MsgOnChanOpenInitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{5}
}
func (m *MsgOnChanOpenInitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenInitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenInitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenInitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenInitResponse.Merge(m, src)
}
func (m *MsgOnChanOpenInitResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenInitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenInitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenInitResponse proto.InternalMessageInfo

// MsgOnChanOpenTry defines an sdk.Msg to for a channel open try callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenTry struct {
	ConnectionHops      []string           `protobuf:"bytes,1,rep,name=connection_hops,json=connectionHops,proto3" json:"connection_hops,omitempty" yaml:"connection_hops"`
	Ordering            types.Order        `protobuf:"varint,2,opt,name=ordering,proto3,enum=ibc.core.channel.v1.Order" json:"ordering,omitempty"`
	Party               types.Counterparty `protobuf:"bytes,3,opt,name=party,proto3" json:"party"`
	Counterparty        types.Counterparty `protobuf:"bytes,4,opt,name=counterparty,proto3" json:"counterparty"`
	CounterpartyVersion string             `protobuf:"bytes,5,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgOnChanOpenTry) Reset()         { *m = MsgOnChanOpenTry{} }
func (m *MsgOnChanOpenTry) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenTry) ProtoMessage()    {}
func (*MsgOnChanOpenTry) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{6}
}
func (m *MsgOnChanOpenTry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenTry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenTry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenTry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenTry.Merge(m, src)
}
func (m *MsgOnChanOpenTry) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenTry) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenTry.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenTry proto.InternalMessageInfo

// MsgOnChanOpenTryResponse defines the Msg/OnChanOpenTry response type.
type MsgOnChanOpenTryResponse struct {
	Result  ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
	Version string             `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *MsgOnChanOpenTryResponse) Reset()         { *m = MsgOnChanOpenTryResponse{} }
func (m *MsgOnChanOpenTryResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenTryResponse) ProtoMessage()    {}
func (*MsgOnChanOpenTryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{7}
}
func (m *MsgOnChanOpenTryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenTryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenTryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenTryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenTryResponse.Merge(m, src)
}
func (m *MsgOnChanOpenTryResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenTryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenTryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenTryResponse proto.InternalMessageInfo

// MsgOnChanOpenAck defines an sdk.Msg to for a channel open ack callback.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenAck struct {
	PortId                string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId             string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
	CounterpartyChannelId string `protobuf:"bytes,3,opt,name=counterparty_channel_id,json=counterpartyChannelId,proto3" json:"counterparty_channel_id,omitempty" yaml:"counterparty_channel_id"`
	CounterpartyVersion   string `protobuf:"bytes,4,opt,name=counterparty_version,json=counterpartyVersion,proto3" json:"counterparty_version,omitempty" yaml:"counterparty_version"`
}

func (m *MsgOnChanOpenAck) Reset()         { *m = MsgOnChanOpenAck{} }
func (m *MsgOnChanOpenAck) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenAck) ProtoMessage()    {}
func (*MsgOnChanOpenAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{8}
}
func (m *MsgOnChanOpenAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenAck.Merge(m, src)
}
func (m *MsgOnChanOpenAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenAck proto.InternalMessageInfo

// MsgOnChanOpenAckResponse defines the Msg/OnChanOpenAck response type.
type MsgOnChanOpenAckResponse struct {
	Result ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
}

func (m *MsgOnChanOpenAckResponse) Reset()         { *m = MsgOnChanOpenAckResponse{} }
func (m *MsgOnChanOpenAckResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenAckResponse) ProtoMessage()    {}
func (*MsgOnChanOpenAckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{9}
}
func (m *MsgOnChanOpenAckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenAckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenAckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenAckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenAckResponse.Merge(m, src)
}
func (m *MsgOnChanOpenAckResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenAckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenAckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenAckResponse proto.InternalMessageInfo

// MsgOnChanOpenConfirm defines an sdk.Msg to for a channel open Confirm callbConfirm.
// It originates from the vIBC sidecar side.
type MsgOnChanOpenConfirm struct {
	PortId    string `protobuf:"bytes,1,opt,name=port_id,json=portId,proto3" json:"port_id,omitempty" yaml:"port_id"`
	ChannelId string `protobuf:"bytes,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty" yaml:"channel_id"`
}

func (m *MsgOnChanOpenConfirm) Reset()         { *m = MsgOnChanOpenConfirm{} }
func (m *MsgOnChanOpenConfirm) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenConfirm) ProtoMessage()    {}
func (*MsgOnChanOpenConfirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{10}
}
func (m *MsgOnChanOpenConfirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenConfirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenConfirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenConfirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenConfirm.Merge(m, src)
}
func (m *MsgOnChanOpenConfirm) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenConfirm) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenConfirm.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenConfirm proto.InternalMessageInfo

// MsgOnChanOpenConfirmResponse defines the Msg/OnChanOpenConfirm response type.
type MsgOnChanOpenConfirmResponse struct {
	Result ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
}

func (m *MsgOnChanOpenConfirmResponse) Reset()         { *m = MsgOnChanOpenConfirmResponse{} }
func (m *MsgOnChanOpenConfirmResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnChanOpenConfirmResponse) ProtoMessage()    {}
func (*MsgOnChanOpenConfirmResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{11}
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnChanOpenConfirmResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnChanOpenConfirmResponse.Merge(m, src)
}
func (m *MsgOnChanOpenConfirmResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnChanOpenConfirmResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnChanOpenConfirmResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnChanOpenConfirmResponse proto.InternalMessageInfo

// MsgOnRecvPacket defines an sdk.Msg to for a packet receipt.
// It originates from the vIBC sidecar side.
type MsgOnRecvPacket struct {
	Packet  types.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Relayer string       `protobuf:"bytes,2,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnRecvPacket) Reset()         { *m = MsgOnRecvPacket{} }
func (m *MsgOnRecvPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnRecvPacket) ProtoMessage()    {}
func (*MsgOnRecvPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{12}
}
func (m *MsgOnRecvPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnRecvPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnRecvPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnRecvPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnRecvPacket.Merge(m, src)
}
func (m *MsgOnRecvPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnRecvPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnRecvPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnRecvPacket proto.InternalMessageInfo

// MsgOnRecvPacketResponse defines the Msg/OnRecvPacket response type.
type MsgOnRecvPacketResponse struct {
	Acknowledgement *types.Acknowledgement `protobuf:"bytes,1,opt,name=acknowledgement,proto3" json:"acknowledgement,omitempty"`
}

func (m *MsgOnRecvPacketResponse) Reset()         { *m = MsgOnRecvPacketResponse{} }
func (m *MsgOnRecvPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnRecvPacketResponse) ProtoMessage()    {}
func (*MsgOnRecvPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{13}
}
func (m *MsgOnRecvPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnRecvPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnRecvPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnRecvPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnRecvPacketResponse.Merge(m, src)
}
func (m *MsgOnRecvPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnRecvPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnRecvPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnRecvPacketResponse proto.InternalMessageInfo

// MsgOnTimeoutPacket defines an sdk.Msg to for a packet receipt.
// It originates from the vIBC sidecar side.
type MsgOnTimeoutPacket struct {
	Packet  types.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Relayer string       `protobuf:"bytes,2,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnTimeoutPacket) Reset()         { *m = MsgOnTimeoutPacket{} }
func (m *MsgOnTimeoutPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnTimeoutPacket) ProtoMessage()    {}
func (*MsgOnTimeoutPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{14}
}
func (m *MsgOnTimeoutPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnTimeoutPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnTimeoutPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnTimeoutPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnTimeoutPacket.Merge(m, src)
}
func (m *MsgOnTimeoutPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnTimeoutPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnTimeoutPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnTimeoutPacket proto.InternalMessageInfo

// MsgOnTimeoutPacketResponse defines the Msg/OnTimeoutPacket response type.
type MsgOnTimeoutPacketResponse struct {
	Result ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
}

func (m *MsgOnTimeoutPacketResponse) Reset()         { *m = MsgOnTimeoutPacketResponse{} }
func (m *MsgOnTimeoutPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnTimeoutPacketResponse) ProtoMessage()    {}
func (*MsgOnTimeoutPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{15}
}
func (m *MsgOnTimeoutPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnTimeoutPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnTimeoutPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnTimeoutPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnTimeoutPacketResponse.Merge(m, src)
}
func (m *MsgOnTimeoutPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnTimeoutPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnTimeoutPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnTimeoutPacketResponse proto.InternalMessageInfo

// MsgOnAcknowledgementPacket defines an sdk.Msg to for a packet acknowledgement.
// It originates from the vIBC sidecar side.
type MsgOnAcknowledgementPacket struct {
	Packet          types.Packet `protobuf:"bytes,1,opt,name=packet,proto3" json:"packet"`
	Acknowledgement []byte       `protobuf:"bytes,2,opt,name=acknowledgement,proto3" json:"acknowledgement,omitempty"`
	Relayer         string       `protobuf:"bytes,3,opt,name=relayer,proto3" json:"relayer,omitempty"`
}

func (m *MsgOnAcknowledgementPacket) Reset()         { *m = MsgOnAcknowledgementPacket{} }
func (m *MsgOnAcknowledgementPacket) String() string { return proto.CompactTextString(m) }
func (*MsgOnAcknowledgementPacket) ProtoMessage()    {}
func (*MsgOnAcknowledgementPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{16}
}
func (m *MsgOnAcknowledgementPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnAcknowledgementPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnAcknowledgementPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnAcknowledgementPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnAcknowledgementPacket.Merge(m, src)
}
func (m *MsgOnAcknowledgementPacket) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnAcknowledgementPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnAcknowledgementPacket.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnAcknowledgementPacket proto.InternalMessageInfo

// MsgOnAcknowledgementPacketResponse defines the Msg/OnAcknowledgementPacket response type.
type MsgOnAcknowledgementPacketResponse struct {
	Result ResponseResultType `protobuf:"varint,1,opt,name=result,proto3,enum=ibc.core.vibc.v1.ResponseResultType" json:"result,omitempty"`
}

func (m *MsgOnAcknowledgementPacketResponse) Reset()         { *m = MsgOnAcknowledgementPacketResponse{} }
func (m *MsgOnAcknowledgementPacketResponse) String() string { return proto.CompactTextString(m) }
func (*MsgOnAcknowledgementPacketResponse) ProtoMessage()    {}
func (*MsgOnAcknowledgementPacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9d1a3d740386b8a9, []int{17}
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgOnAcknowledgementPacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgOnAcknowledgementPacketResponse.Merge(m, src)
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgOnAcknowledgementPacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgOnAcknowledgementPacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgOnAcknowledgementPacketResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("ibc.core.vibc.v1.ResponseResultType", ResponseResultType_name, ResponseResultType_value)
	proto.RegisterType((*MsgSendPacket)(nil), "ibc.core.vibc.v1.MsgSendPacket")
	proto.RegisterType((*MsgSendPacketResponse)(nil), "ibc.core.vibc.v1.MsgSendPacketResponse")
	proto.RegisterType((*MsgChannelOpenInit)(nil), "ibc.core.vibc.v1.MsgChannelOpenInit")
	proto.RegisterType((*MsgChannelOpenInitResponse)(nil), "ibc.core.vibc.v1.MsgChannelOpenInitResponse")
	proto.RegisterType((*MsgOnChanOpenInit)(nil), "ibc.core.vibc.v1.MsgOnChanOpenInit")
	proto.RegisterType((*MsgOnChanOpenInitResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenInitResponse")
	proto.RegisterType((*MsgOnChanOpenTry)(nil), "ibc.core.vibc.v1.MsgOnChanOpenTry")
	proto.RegisterType((*MsgOnChanOpenTryResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenTryResponse")
	proto.RegisterType((*MsgOnChanOpenAck)(nil), "ibc.core.vibc.v1.MsgOnChanOpenAck")
	proto.RegisterType((*MsgOnChanOpenAckResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenAckResponse")
	proto.RegisterType((*MsgOnChanOpenConfirm)(nil), "ibc.core.vibc.v1.MsgOnChanOpenConfirm")
	proto.RegisterType((*MsgOnChanOpenConfirmResponse)(nil), "ibc.core.vibc.v1.MsgOnChanOpenConfirmResponse")
	proto.RegisterType((*MsgOnRecvPacket)(nil), "ibc.core.vibc.v1.MsgOnRecvPacket")
	proto.RegisterType((*MsgOnRecvPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnRecvPacketResponse")
	proto.RegisterType((*MsgOnTimeoutPacket)(nil), "ibc.core.vibc.v1.MsgOnTimeoutPacket")
	proto.RegisterType((*MsgOnTimeoutPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnTimeoutPacketResponse")
	proto.RegisterType((*MsgOnAcknowledgementPacket)(nil), "ibc.core.vibc.v1.MsgOnAcknowledgementPacket")
	proto.RegisterType((*MsgOnAcknowledgementPacketResponse)(nil), "ibc.core.vibc.v1.MsgOnAcknowledgementPacketResponse")
}

func init() { proto.RegisterFile("ibc/core/vibc/v1/tx.proto", fileDescriptor_9d1a3d740386b8a9) }

var fileDescriptor_9d1a3d740386b8a9 = []byte{
	// 1205 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x58, 0xcd, 0x6f, 0xe2, 0xc6,
	0x1b, 0xc6, 0x84, 0x7c, 0xbd, 0xc9, 0x02, 0xf1, 0x26, 0xbf, 0x10, 0x6f, 0x84, 0x89, 0x7f, 0x51,
	0x93, 0xfd, 0x02, 0x85, 0xdd, 0xb6, 0x6a, 0xb4, 0xab, 0x2a, 0x50, 0xaa, 0x45, 0x6d, 0x02, 0x32,
	0x24, 0x52, 0x57, 0x55, 0x29, 0x98, 0x29, 0xb1, 0x00, 0x8f, 0x6b, 0x1b, 0xba, 0x1c, 0x7a, 0xea,
	0x65, 0x1b, 0xf5, 0xd0, 0x7f, 0x20, 0xd2, 0x4a, 0x55, 0xcf, 0xfd, 0x37, 0xf6, 0xb8, 0xaa, 0x7a,
	0xe8, 0x09, 0x55, 0x89, 0x2a, 0xed, 0x99, 0x5b, 0x6f, 0x95, 0xed, 0xb1, 0xb1, 0x8d, 0x11, 0x89,
	0x16, 0xe5, 0xd4, 0xdb, 0xcc, 0xbc, 0xcf, 0xfb, 0xf5, 0x3c, 0xe3, 0xf1, 0xd8, 0xb0, 0x21, 0xd6,
	0x84, 0x94, 0x80, 0x15, 0x94, 0xea, 0xea, 0xa3, 0xee, 0x5e, 0x4a, 0x7b, 0x91, 0x94, 0x15, 0xac,
	0x61, 0x3a, 0x2a, 0xd6, 0x84, 0xa4, 0x6e, 0x4a, 0xea, 0xa6, 0x64, 0x77, 0x8f, 0x59, 0x6d, 0xe0,
	0x06, 0x36, 0x8c, 0x29, 0x7d, 0x64, 0xe2, 0x18, 0xd6, 0x0e, 0x21, 0xb4, 0x44, 0x24, 0x69, 0x7a,
	0x10, 0x73, 0x44, 0x00, 0x5b, 0x43, 0xc0, 0x69, 0x55, 0x92, 0x50, 0xcb, 0x40, 0x98, 0x43, 0x02,
	0xd9, 0x19, 0x42, 0x70, 0xbb, 0x2d, 0x6a, 0x6d, 0x2b, 0x8e, 0x3d, 0x33, 0x81, 0xdc, 0x05, 0x05,
	0xb7, 0x0e, 0xd5, 0x46, 0x09, 0x49, 0xf5, 0x62, 0x55, 0x68, 0x22, 0x8d, 0xfe, 0x18, 0xc2, 0x2a,
	0xee, 0x28, 0x02, 0xaa, 0xc8, 0x58, 0xd1, 0x2a, 0x62, 0x3d, 0x46, 0x25, 0xa8, 0xdd, 0xc5, 0xcc,
	0xc6, 0xa0, 0xcf, 0xae, 0xf5, 0xaa, 0xed, 0xd6, 0x3e, 0xe7, 0xb6, 0x73, 0xfc, 0xb2, 0xb9, 0x50,
	0xc4, 0x8a, 0x96, 0xaf, 0xd3, 0xcf, 0x60, 0x85, 0x00, 0x48, 0x4d, 0x7a, 0x8c, 0xa0, 0x11, 0x63,
	0x73, 0xd0, 0x67, 0x63, 0xae, 0x18, 0x43, 0x08, 0xc7, 0x47, 0xcc, 0xb5, 0xac, 0xb9, 0x94, 0xaf,
	0xd3, 0x4f, 0x60, 0x9e, 0xd8, 0x63, 0x33, 0x09, 0x6a, 0x77, 0x29, 0xbd, 0x99, 0xb4, 0x39, 0xb4,
	0xfa, 0xed, 0xee, 0x25, 0x89, 0x43, 0x26, 0xf4, 0xba, 0xcf, 0x06, 0x78, 0xcb, 0x65, 0x7f, 0xe1,
	0xe5, 0x2b, 0x36, 0xf0, 0xf6, 0x15, 0x1b, 0xe0, 0x7e, 0xa2, 0x60, 0xcd, 0xd5, 0x24, 0x8f, 0x54,
	0x19, 0x4b, 0x2a, 0xa2, 0x9f, 0xc0, 0x9c, 0x82, 0xd4, 0x4e, 0x4b, 0x33, 0x9a, 0x0c, 0xa7, 0xb7,
	0x93, 0x5e, 0x91, 0x92, 0x16, 0x96, 0x37, 0x70, 0xe5, 0x9e, 0x8c, 0x78, 0xe2, 0x43, 0xa7, 0x60,
	0x41, 0x45, 0xdf, 0x76, 0x90, 0x24, 0x20, 0xa3, 0xc1, 0x50, 0xe6, 0xf6, 0xa0, 0xcf, 0x46, 0x48,
	0x83, 0xc4, 0xc2, 0xf1, 0x36, 0x68, 0x3f, 0xa4, 0x97, 0xc4, 0xfd, 0x48, 0x01, 0x7d, 0xa8, 0x36,
	0x48, 0xd9, 0x05, 0x19, 0x49, 0x79, 0x49, 0xd4, 0xe8, 0xfb, 0x30, 0xef, 0x66, 0x9c, 0x1e, 0xf4,
	0xd9, 0xb0, 0x19, 0xcc, 0xa6, 0x7a, 0x4e, 0x36, 0x49, 0x76, 0x50, 0x13, 0x7c, 0x17, 0x6a, 0x5a,
	0xc0, 0x8c, 0x96, 0x62, 0xd3, 0xf3, 0x18, 0xc0, 0xa1, 0xa1, 0x59, 0xd5, 0xda, 0xa0, 0xcf, 0xae,
	0x98, 0x55, 0x39, 0xc5, 0x5b, 0x14, 0x6c, 0xd9, 0x62, 0x30, 0xdf, 0x45, 0x8a, 0x2a, 0x62, 0xc9,
	0x94, 0x9d, 0xb7, 0xa6, 0xdc, 0xdf, 0x41, 0x58, 0x39, 0x54, 0x1b, 0x05, 0x49, 0x4f, 0x68, 0x37,
	0x9e, 0x85, 0x88, 0x80, 0x25, 0x09, 0x09, 0x9a, 0x88, 0xa5, 0xca, 0x29, 0x96, 0xd5, 0x18, 0x95,
	0x98, 0xd9, 0x5d, 0xcc, 0x30, 0x83, 0x3e, 0xfb, 0x3f, 0x92, 0xca, 0x0d, 0xe0, 0xf8, 0xf0, 0x70,
	0xe5, 0x19, 0x96, 0x55, 0xfa, 0x03, 0x58, 0xc0, 0x4a, 0x1d, 0x29, 0xa2, 0xd4, 0x30, 0xb2, 0x86,
	0xd3, 0x8c, 0x2f, 0x23, 0x05, 0x1d, 0xc4, 0xdb, 0x58, 0xfa, 0x29, 0xcc, 0xca, 0x55, 0x45, 0xeb,
	0x91, 0x1d, 0xb6, 0xe5, 0x4f, 0x23, 0xee, 0x48, 0x1a, 0x52, 0x0c, 0x20, 0xe1, 0xd2, 0xf4, 0xa2,
	0x3f, 0x83, 0x65, 0xc1, 0x61, 0x8c, 0x85, 0xae, 0x17, 0xc5, 0xe5, 0x4c, 0x3f, 0x85, 0x5b, 0xc6,
	0xa0, 0x62, 0xd1, 0x37, 0x6b, 0x30, 0x1e, 0x1b, 0xf4, 0xd9, 0x55, 0xb2, 0x0f, 0x9c, 0x66, 0x8e,
	0x5f, 0x36, 0xe6, 0x27, 0xe6, 0xd4, 0xa1, 0x6a, 0x0f, 0x36, 0x46, 0x68, 0x9e, 0xd2, 0x9e, 0x1f,
	0x2b, 0x2e, 0xd9, 0xdc, 0xff, 0x04, 0x21, 0xea, 0xca, 0x5d, 0x56, 0x7a, 0xff, 0x29, 0x6c, 0x29,
	0xcc, 0xc3, 0xaa, 0x73, 0xee, 0x11, 0x9a, 0x1d, 0xf4, 0xd9, 0x3b, 0x16, 0x1b, 0xa3, 0x28, 0x8e,
	0xbf, 0xed, 0x5c, 0x1e, 0x95, 0xfd, 0x05, 0xc4, 0xbc, 0xd4, 0xdf, 0x90, 0xea, 0xbf, 0x79, 0x55,
	0x3f, 0x10, 0x9a, 0xd7, 0x3b, 0xd0, 0xdc, 0x47, 0x4d, 0xf0, 0x8a, 0x47, 0xcd, 0x73, 0x58, 0x77,
	0x31, 0xe5, 0x08, 0x31, 0x63, 0x84, 0xe0, 0x06, 0x7d, 0x36, 0xee, 0x43, 0xa9, 0x33, 0xde, 0x9a,
	0xd3, 0x32, 0x7c, 0xfb, 0x8c, 0xd3, 0x2a, 0x34, 0x15, 0xad, 0xbe, 0xf2, 0x68, 0x75, 0x20, 0x34,
	0xa7, 0xa3, 0x15, 0x51, 0xe4, 0x07, 0x0a, 0x56, 0x5d, 0x09, 0xb2, 0x58, 0xfa, 0x46, 0x54, 0xda,
	0x37, 0xa0, 0x8a, 0xa3, 0xcb, 0x1a, 0x6c, 0xfa, 0x15, 0x31, 0xd5, 0x4e, 0x65, 0x88, 0x18, 0x39,
	0x78, 0x24, 0x74, 0xc9, 0x1d, 0xe6, 0x23, 0x98, 0x93, 0x8d, 0x91, 0x11, 0x76, 0x29, 0x7d, 0xc7,
	0xf7, 0x69, 0x35, 0xc1, 0xe4, 0x39, 0x25, 0x0e, 0xfa, 0x4e, 0x57, 0x50, 0xab, 0xda, 0x43, 0x8a,
	0xb5, 0xd3, 0xc9, 0xd4, 0xd1, 0x15, 0x86, 0x75, 0x4f, 0x46, 0xbb, 0xa1, 0x23, 0x88, 0x54, 0x85,
	0xa6, 0x84, 0xbf, 0x6b, 0xa1, 0x7a, 0x03, 0xe9, 0x17, 0x2d, 0x52, 0xc2, 0xb6, 0x6f, 0x09, 0x07,
	0x6e, 0x2c, 0xef, 0x75, 0x26, 0x2d, 0xaa, 0xc6, 0x85, 0xa1, 0x20, 0x95, 0xc5, 0x36, 0xc2, 0x1d,
	0xed, 0x66, 0xba, 0xfc, 0xda, 0xb8, 0x1a, 0x78, 0x92, 0x4e, 0x55, 0xb9, 0x5f, 0x29, 0x92, 0xc2,
	0x43, 0xc3, 0xbb, 0xf7, 0xb7, 0x3b, 0x2a, 0x83, 0xde, 0xe7, 0xf2, 0x08, 0xc1, 0x4e, 0x26, 0x66,
	0xc6, 0x31, 0x71, 0x0a, 0xdc, 0xf8, 0x32, 0xa7, 0xc9, 0xc8, 0xbd, 0x3f, 0x28, 0xa0, 0x47, 0x41,
	0xf4, 0xfb, 0x90, 0xe0, 0x73, 0xa5, 0x62, 0xe1, 0xa8, 0x94, 0xab, 0xf0, 0xb9, 0xd2, 0xf1, 0xe7,
	0xe5, 0x4a, 0xf9, 0x8b, 0x62, 0xae, 0x72, 0x7c, 0x54, 0x2a, 0xe6, 0xb2, 0xf9, 0x4f, 0xf3, 0xb9,
	0x4f, 0xa2, 0x01, 0x26, 0x72, 0x76, 0x9e, 0x58, 0x72, 0x2c, 0xd1, 0x3b, 0xb0, 0xe1, 0xeb, 0x76,
	0x54, 0x28, 0x14, 0xa3, 0x14, 0xb3, 0x70, 0x76, 0x9e, 0x08, 0xe9, 0x63, 0xfa, 0x21, 0x6c, 0xfa,
	0x02, 0x4b, 0xc7, 0xd9, 0x6c, 0xae, 0x54, 0x8a, 0x06, 0x99, 0xa5, 0xb3, 0xf3, 0xc4, 0x3c, 0x99,
	0xd2, 0x77, 0x81, 0xf1, 0x85, 0xe7, 0x78, 0xbe, 0xc0, 0x47, 0x67, 0x98, 0xc5, 0xb3, 0xf3, 0xc4,
	0xac, 0x31, 0x61, 0x42, 0x2f, 0x7f, 0x89, 0x07, 0xd2, 0x6f, 0x67, 0x21, 0x72, 0x22, 0x2a, 0x5a,
	0xa7, 0xda, 0xca, 0x67, 0xb2, 0xd9, 0xd3, 0xaa, 0x28, 0xd1, 0x35, 0x08, 0x7b, 0xee, 0x81, 0xff,
	0x1f, 0x25, 0x6c, 0xe4, 0x16, 0xc3, 0xdc, 0xbf, 0x02, 0xc8, 0x96, 0xa4, 0x02, 0xb7, 0xdc, 0x17,
	0x11, 0x6e, 0x82, 0x77, 0x59, 0xe9, 0x31, 0xf7, 0x26, 0x63, 0xfc, 0x13, 0xe8, 0xef, 0xbc, 0x49,
	0x09, 0x0e, 0x84, 0xe6, 0xc4, 0x04, 0xce, 0x57, 0x41, 0x13, 0x56, 0x46, 0x8f, 0xf0, 0xf7, 0x26,
	0x04, 0x20, 0x38, 0x26, 0x79, 0x35, 0x9c, 0x9d, 0xec, 0x4b, 0x58, 0x76, 0x1d, 0xa3, 0x5b, 0x63,
	0xfc, 0x87, 0x10, 0xe6, 0xee, 0x44, 0x88, 0x1d, 0xfd, 0x7b, 0x58, 0x1f, 0xf7, 0xa4, 0x3f, 0x18,
	0x13, 0xc5, 0x17, 0xcd, 0x3c, 0xbe, 0x0e, 0xda, 0x4e, 0x8f, 0x20, 0xe2, 0x3d, 0x40, 0xb7, 0xc7,
	0x04, 0x72, 0xa1, 0x98, 0x07, 0x57, 0x41, 0x59, 0x69, 0xd2, 0xbf, 0x53, 0xb0, 0x32, 0xdc, 0xea,
	0x25, 0xb1, 0x8e, 0x84, 0xaa, 0xa2, 0x27, 0xf7, 0x7e, 0xee, 0xf9, 0x27, 0xf7, 0xa0, 0xc6, 0x24,
	0x1f, 0xf7, 0xbd, 0x76, 0x02, 0xe0, 0xf8, 0x92, 0x67, 0x7d, 0x7d, 0x87, 0x00, 0x66, 0x67, 0x02,
	0xc0, 0x8a, 0x9b, 0x39, 0x7c, 0x7d, 0x11, 0xa7, 0xde, 0x5c, 0xc4, 0xa9, 0xbf, 0x2e, 0xe2, 0xd4,
	0xcf, 0x97, 0xf1, 0xc0, 0x9b, 0xcb, 0x78, 0xe0, 0xcf, 0xcb, 0x78, 0xe0, 0xf9, 0xa3, 0x86, 0xa8,
	0x9d, 0x76, 0x6a, 0x49, 0x01, 0xb7, 0x53, 0x02, 0x56, 0xdb, 0x58, 0x4d, 0x89, 0x35, 0xe1, 0x61,
	0x03, 0xa7, 0xba, 0x1f, 0xa6, 0xda, 0xb8, 0xde, 0x69, 0x21, 0xd5, 0xf1, 0x3f, 0x44, 0xeb, 0xc9,
	0x48, 0xad, 0xcd, 0x19, 0xff, 0x1e, 0x1e, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x43, 0xf2, 0x02,
	0x28, 0x2d, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VirtualIBCChainClient is the client API for VirtualIBCChain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VirtualIBCChainClient interface {
	// OnChanOpenInit defines a rpc handler method for MsgOnChanOpenInit.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<INIT>
	OnChanOpenInit(ctx context.Context, in *MsgOnChanOpenInit, opts ...grpc.CallOption) (*MsgOnChanOpenInitResponse, error)
	// OnChanOpenTry defines a rpc handler method for MsgOnChanOpenTry.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<TRYOPEN>
	OnChanOpenTry(ctx context.Context, in *MsgOnChanOpenTry, opts ...grpc.CallOption) (*MsgOnChanOpenTryResponse, error)
	// OnChanOpenAck defines a rpc handler method for MsgOnChanOpenAck.
	// Proofs:
	// - exists: channel<INIT>
	// - non-exists: channel<OPEN>
	OnChanOpenAck(ctx context.Context, in *MsgOnChanOpenAck, opts ...grpc.CallOption) (*MsgOnChanOpenAckResponse, error)
	// OnChanOpenConfirm defines a rpc handler method for MsgOnChanOpenConfirm.
	// Proofs:
	// - exists: channel<TRYOPEN>
	// - non-exists: channel<OPEN>
	OnChanOpenConfirm(ctx context.Context, in *MsgOnChanOpenConfirm, opts ...grpc.CallOption) (*MsgOnChanOpenConfirmResponse, error)
	// OnRecvPacket defines a rpc handler method for MsgOnRecvPacket.
	// Proofs:
	// - exists: packet commitment
	// - exists: packet receipt OR packet recv sequence
	OnRecvPacket(ctx context.Context, in *MsgOnRecvPacket, opts ...grpc.CallOption) (*MsgOnRecvPacketResponse, error)
	// OnAcknowledgementPacket defines a rpc handler method for MsgOnAcknowledgementPacket.
	OnAcknowledgementPacket(ctx context.Context, in *MsgOnAcknowledgementPacket, opts ...grpc.CallOption) (*MsgOnAcknowledgementPacketResponse, error)
	// OnTimeoutPacket defines a rpc handler method for MsgOnTimeoutPacket.
	OnTimeoutPacket(ctx context.Context, in *MsgOnTimeoutPacket, opts ...grpc.CallOption) (*MsgOnTimeoutPacketResponse, error)
}

type virtualIBCChainClient struct {
	cc grpc1.ClientConn
}

func NewVirtualIBCChainClient(cc grpc1.ClientConn) VirtualIBCChainClient {
	return &virtualIBCChainClient{cc}
}

func (c *virtualIBCChainClient) OnChanOpenInit(ctx context.Context, in *MsgOnChanOpenInit, opts ...grpc.CallOption) (*MsgOnChanOpenInitResponse, error) {
	out := new(MsgOnChanOpenInitResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenTry(ctx context.Context, in *MsgOnChanOpenTry, opts ...grpc.CallOption) (*MsgOnChanOpenTryResponse, error) {
	out := new(MsgOnChanOpenTryResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenTry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenAck(ctx context.Context, in *MsgOnChanOpenAck, opts ...grpc.CallOption) (*MsgOnChanOpenAckResponse, error) {
	out := new(MsgOnChanOpenAckResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnChanOpenConfirm(ctx context.Context, in *MsgOnChanOpenConfirm, opts ...grpc.CallOption) (*MsgOnChanOpenConfirmResponse, error) {
	out := new(MsgOnChanOpenConfirmResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenConfirm", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnRecvPacket(ctx context.Context, in *MsgOnRecvPacket, opts ...grpc.CallOption) (*MsgOnRecvPacketResponse, error) {
	out := new(MsgOnRecvPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnRecvPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnAcknowledgementPacket(ctx context.Context, in *MsgOnAcknowledgementPacket, opts ...grpc.CallOption) (*MsgOnAcknowledgementPacketResponse, error) {
	out := new(MsgOnAcknowledgementPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnAcknowledgementPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCChainClient) OnTimeoutPacket(ctx context.Context, in *MsgOnTimeoutPacket, opts ...grpc.CallOption) (*MsgOnTimeoutPacketResponse, error) {
	out := new(MsgOnTimeoutPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCChain/OnTimeoutPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualIBCChainServer is the server API for VirtualIBCChain service.
type VirtualIBCChainServer interface {
	// OnChanOpenInit defines a rpc handler method for MsgOnChanOpenInit.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<INIT>
	OnChanOpenInit(context.Context, *MsgOnChanOpenInit) (*MsgOnChanOpenInitResponse, error)
	// OnChanOpenTry defines a rpc handler method for MsgOnChanOpenTry.
	// Proofs:
	// - exists: channel sequence for channel_id
	// - non-exists: channel<TRYOPEN>
	OnChanOpenTry(context.Context, *MsgOnChanOpenTry) (*MsgOnChanOpenTryResponse, error)
	// OnChanOpenAck defines a rpc handler method for MsgOnChanOpenAck.
	// Proofs:
	// - exists: channel<INIT>
	// - non-exists: channel<OPEN>
	OnChanOpenAck(context.Context, *MsgOnChanOpenAck) (*MsgOnChanOpenAckResponse, error)
	// OnChanOpenConfirm defines a rpc handler method for MsgOnChanOpenConfirm.
	// Proofs:
	// - exists: channel<TRYOPEN>
	// - non-exists: channel<OPEN>
	OnChanOpenConfirm(context.Context, *MsgOnChanOpenConfirm) (*MsgOnChanOpenConfirmResponse, error)
	// OnRecvPacket defines a rpc handler method for MsgOnRecvPacket.
	// Proofs:
	// - exists: packet commitment
	// - exists: packet receipt OR packet recv sequence
	OnRecvPacket(context.Context, *MsgOnRecvPacket) (*MsgOnRecvPacketResponse, error)
	// OnAcknowledgementPacket defines a rpc handler method for MsgOnAcknowledgementPacket.
	OnAcknowledgementPacket(context.Context, *MsgOnAcknowledgementPacket) (*MsgOnAcknowledgementPacketResponse, error)
	// OnTimeoutPacket defines a rpc handler method for MsgOnTimeoutPacket.
	OnTimeoutPacket(context.Context, *MsgOnTimeoutPacket) (*MsgOnTimeoutPacketResponse, error)
}

// UnimplementedVirtualIBCChainServer can be embedded to have forward compatible implementations.
type UnimplementedVirtualIBCChainServer struct {
}

func (*UnimplementedVirtualIBCChainServer) OnChanOpenInit(ctx context.Context, req *MsgOnChanOpenInit) (*MsgOnChanOpenInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenInit not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenTry(ctx context.Context, req *MsgOnChanOpenTry) (*MsgOnChanOpenTryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenTry not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenAck(ctx context.Context, req *MsgOnChanOpenAck) (*MsgOnChanOpenAckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenAck not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnChanOpenConfirm(ctx context.Context, req *MsgOnChanOpenConfirm) (*MsgOnChanOpenConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnChanOpenConfirm not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnRecvPacket(ctx context.Context, req *MsgOnRecvPacket) (*MsgOnRecvPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnRecvPacket not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnAcknowledgementPacket(ctx context.Context, req *MsgOnAcknowledgementPacket) (*MsgOnAcknowledgementPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnAcknowledgementPacket not implemented")
}
func (*UnimplementedVirtualIBCChainServer) OnTimeoutPacket(ctx context.Context, req *MsgOnTimeoutPacket) (*MsgOnTimeoutPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnTimeoutPacket not implemented")
}

func RegisterVirtualIBCChainServer(s grpc1.Server, srv VirtualIBCChainServer) {
	s.RegisterService(&_VirtualIBCChain_serviceDesc, srv)
}

func _VirtualIBCChain_OnChanOpenInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenInit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenInit(ctx, req.(*MsgOnChanOpenInit))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenTry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenTry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenTry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenTry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenTry(ctx, req.(*MsgOnChanOpenTry))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenAck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenAck(ctx, req.(*MsgOnChanOpenAck))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnChanOpenConfirm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnChanOpenConfirm)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnChanOpenConfirm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnChanOpenConfirm",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnChanOpenConfirm(ctx, req.(*MsgOnChanOpenConfirm))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnRecvPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnRecvPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnRecvPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnRecvPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnRecvPacket(ctx, req.(*MsgOnRecvPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnAcknowledgementPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnAcknowledgementPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnAcknowledgementPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnAcknowledgementPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnAcknowledgementPacket(ctx, req.(*MsgOnAcknowledgementPacket))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCChain_OnTimeoutPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgOnTimeoutPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCChainServer).OnTimeoutPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCChain/OnTimeoutPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCChainServer).OnTimeoutPacket(ctx, req.(*MsgOnTimeoutPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualIBCChain_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.core.vibc.v1.VirtualIBCChain",
	HandlerType: (*VirtualIBCChainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnChanOpenInit",
			Handler:    _VirtualIBCChain_OnChanOpenInit_Handler,
		},
		{
			MethodName: "OnChanOpenTry",
			Handler:    _VirtualIBCChain_OnChanOpenTry_Handler,
		},
		{
			MethodName: "OnChanOpenAck",
			Handler:    _VirtualIBCChain_OnChanOpenAck_Handler,
		},
		{
			MethodName: "OnChanOpenConfirm",
			Handler:    _VirtualIBCChain_OnChanOpenConfirm_Handler,
		},
		{
			MethodName: "OnRecvPacket",
			Handler:    _VirtualIBCChain_OnRecvPacket_Handler,
		},
		{
			MethodName: "OnAcknowledgementPacket",
			Handler:    _VirtualIBCChain_OnAcknowledgementPacket_Handler,
		},
		{
			MethodName: "OnTimeoutPacket",
			Handler:    _VirtualIBCChain_OnTimeoutPacket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/core/vibc/v1/tx.proto",
}

// VirtualIBCSidecarClient is the client API for VirtualIBCSidecar service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VirtualIBCSidecarClient interface {
	// In the default case, the chain side is passive in the channel handshake process.
	// vIBC differs from IBC in that it allows the chain side to actively initiate the channel handshake.
	// ChannelOpenInit defines a rpc handler method for MsgChannelOpenInit originating from the chain side.
	ChannelOpenInit(ctx context.Context, in *MsgChannelOpenInit, opts ...grpc.CallOption) (*MsgChannelOpenInitResponse, error)
	// The chain is also active in the initiation of the packet lifecycle.
	// SendPacket defines a rpc handler method for MsgSendPacket.
	SendPacket(ctx context.Context, in *MsgSendPacket, opts ...grpc.CallOption) (*MsgSendPacketResponse, error)
}

type virtualIBCSidecarClient struct {
	cc grpc1.ClientConn
}

func NewVirtualIBCSidecarClient(cc grpc1.ClientConn) VirtualIBCSidecarClient {
	return &virtualIBCSidecarClient{cc}
}

func (c *virtualIBCSidecarClient) ChannelOpenInit(ctx context.Context, in *MsgChannelOpenInit, opts ...grpc.CallOption) (*MsgChannelOpenInitResponse, error) {
	out := new(MsgChannelOpenInitResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/ChannelOpenInit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *virtualIBCSidecarClient) SendPacket(ctx context.Context, in *MsgSendPacket, opts ...grpc.CallOption) (*MsgSendPacketResponse, error) {
	out := new(MsgSendPacketResponse)
	err := c.cc.Invoke(ctx, "/ibc.core.vibc.v1.VirtualIBCSidecar/SendPacket", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VirtualIBCSidecarServer is the server API for VirtualIBCSidecar service.
type VirtualIBCSidecarServer interface {
	// In the default case, the chain side is passive in the channel handshake process.
	// vIBC differs from IBC in that it allows the chain side to actively initiate the channel handshake.
	// ChannelOpenInit defines a rpc handler method for MsgChannelOpenInit originating from the chain side.
	ChannelOpenInit(context.Context, *MsgChannelOpenInit) (*MsgChannelOpenInitResponse, error)
	// The chain is also active in the initiation of the packet lifecycle.
	// SendPacket defines a rpc handler method for MsgSendPacket.
	SendPacket(context.Context, *MsgSendPacket) (*MsgSendPacketResponse, error)
}

// UnimplementedVirtualIBCSidecarServer can be embedded to have forward compatible implementations.
type UnimplementedVirtualIBCSidecarServer struct {
}

func (*UnimplementedVirtualIBCSidecarServer) ChannelOpenInit(ctx context.Context, req *MsgChannelOpenInit) (*MsgChannelOpenInitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelOpenInit not implemented")
}
func (*UnimplementedVirtualIBCSidecarServer) SendPacket(ctx context.Context, req *MsgSendPacket) (*MsgSendPacketResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPacket not implemented")
}

func RegisterVirtualIBCSidecarServer(s grpc1.Server, srv VirtualIBCSidecarServer) {
	s.RegisterService(&_VirtualIBCSidecar_serviceDesc, srv)
}

func _VirtualIBCSidecar_ChannelOpenInit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgChannelOpenInit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).ChannelOpenInit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/ChannelOpenInit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).ChannelOpenInit(ctx, req.(*MsgChannelOpenInit))
	}
	return interceptor(ctx, in, info, handler)
}

func _VirtualIBCSidecar_SendPacket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSendPacket)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VirtualIBCSidecarServer).SendPacket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ibc.core.vibc.v1.VirtualIBCSidecar/SendPacket",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VirtualIBCSidecarServer).SendPacket(ctx, req.(*MsgSendPacket))
	}
	return interceptor(ctx, in, info, handler)
}

var _VirtualIBCSidecar_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ibc.core.vibc.v1.VirtualIBCSidecar",
	HandlerType: (*VirtualIBCSidecarServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ChannelOpenInit",
			Handler:    _VirtualIBCSidecar_ChannelOpenInit_Handler,
		},
		{
			MethodName: "SendPacket",
			Handler:    _VirtualIBCSidecar_SendPacket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ibc/core/vibc/v1/tx.proto",
}

func (m *MsgSendPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.SourceChannelId) > 0 {
		i -= len(m.SourceChannelId)
		copy(dAtA[i:], m.SourceChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourceChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SourcePortId) > 0 {
		i -= len(m.SourcePortId)
		copy(dAtA[i:], m.SourcePortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SourcePortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSendPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSendPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSendPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgChannelOpenInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgChannelOpenInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgChannelOpenInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Channel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgChannelOpenInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgChannelOpenInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgChannelOpenInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenInit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenInit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenInit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartyVersion) > 0 {
		i -= len(m.PartyVersion)
		copy(dAtA[i:], m.PartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PartyVersion)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Counterparty.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Party.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Ordering != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Ordering))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ConnectionHops) > 0 {
		for iNdEx := len(m.ConnectionHops) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConnectionHops[iNdEx])
			copy(dAtA[i:], m.ConnectionHops[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.ConnectionHops[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenInitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenInitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenInitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenTry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenTry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenTry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x2a
	}
	{
		size, err := m.Counterparty.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.Party.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Ordering != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Ordering))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ConnectionHops) > 0 {
		for iNdEx := len(m.ConnectionHops) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ConnectionHops[iNdEx])
			copy(dAtA[i:], m.ConnectionHops[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.ConnectionHops[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenTryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenTryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenTryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CounterpartyVersion) > 0 {
		i -= len(m.CounterpartyVersion)
		copy(dAtA[i:], m.CounterpartyVersion)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CounterpartyChannelId) > 0 {
		i -= len(m.CounterpartyChannelId)
		copy(dAtA[i:], m.CounterpartyChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CounterpartyChannelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenAckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenAckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenAckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenConfirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenConfirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenConfirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChannelId) > 0 {
		i -= len(m.ChannelId)
		copy(dAtA[i:], m.ChannelId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ChannelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PortId) > 0 {
		i -= len(m.PortId)
		copy(dAtA[i:], m.PortId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PortId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnChanOpenConfirmResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnChanOpenConfirmResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnChanOpenConfirmResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnRecvPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnRecvPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnRecvPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnRecvPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnRecvPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnRecvPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Acknowledgement != nil {
		{
			size, err := m.Acknowledgement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnTimeoutPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnTimeoutPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnTimeoutPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnTimeoutPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnTimeoutPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnTimeoutPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgOnAcknowledgementPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnAcknowledgementPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnAcknowledgementPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Relayer) > 0 {
		i -= len(m.Relayer)
		copy(dAtA[i:], m.Relayer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Relayer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Acknowledgement) > 0 {
		i -= len(m.Acknowledgement)
		copy(dAtA[i:], m.Acknowledgement)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Acknowledgement)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Packet.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgOnAcknowledgementPacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgOnAcknowledgementPacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgOnAcknowledgementPacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Result != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgSendPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourcePortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SourceChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Channel.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgSendPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	if m.Sequence != 0 {
		n += 1 + sovTx(uint64(m.Sequence))
	}
	return n
}

func (m *MsgChannelOpenInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Channel.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgChannelOpenInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenInit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConnectionHops) > 0 {
		for _, s := range m.ConnectionHops {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Ordering != 0 {
		n += 1 + sovTx(uint64(m.Ordering))
	}
	l = m.Party.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Counterparty.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.PartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenInitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenTry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ConnectionHops) > 0 {
		for _, s := range m.ConnectionHops {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Ordering != 0 {
		n += 1 + sovTx(uint64(m.Ordering))
	}
	l = m.Party.Size()
	n += 1 + l + sovTx(uint64(l))
	l = m.Counterparty.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenTryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.CounterpartyVersion)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenAckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	return n
}

func (m *MsgOnChanOpenConfirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PortId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ChannelId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnChanOpenConfirmResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	return n
}

func (m *MsgOnRecvPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnRecvPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Acknowledgement != nil {
		l = m.Acknowledgement.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnTimeoutPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnTimeoutPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	return n
}

func (m *MsgOnAcknowledgementPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Packet.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Acknowledgement)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Relayer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgOnAcknowledgementPacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovTx(uint64(m.Result))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgSendPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourcePortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourcePortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSendPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSendPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSendPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgChannelOpenInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgChannelOpenInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgChannelOpenInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Channel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgChannelOpenInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgChannelOpenInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgChannelOpenInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenInit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenInit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenInit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionHops", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionHops = append(m.ConnectionHops, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			m.Ordering = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordering |= types.Order(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Party", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Party.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counterparty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Counterparty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenInitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenInitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenInitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenTry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenTry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenTry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionHops", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConnectionHops = append(m.ConnectionHops, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordering", wireType)
			}
			m.Ordering = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordering |= types.Order(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Party", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Party.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counterparty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Counterparty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenTryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenTryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenTryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CounterpartyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CounterpartyVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenAckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenAckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenAckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenConfirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnChanOpenConfirmResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirmResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnChanOpenConfirmResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnRecvPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnRecvPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnRecvPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnRecvPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnRecvPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnRecvPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledgement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Acknowledgement == nil {
				m.Acknowledgement = &types.Acknowledgement{}
			}
			if err := m.Acknowledgement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnTimeoutPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnTimeoutPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnTimeoutPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnTimeoutPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnTimeoutPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnTimeoutPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnAcknowledgementPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Packet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Packet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Acknowledgement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Acknowledgement = append(m.Acknowledgement[:0], dAtA[iNdEx:postIndex]...)
			if m.Acknowledgement == nil {
				m.Acknowledgement = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Relayer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Relayer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgOnAcknowledgementPacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgOnAcknowledgementPacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= ResponseResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
